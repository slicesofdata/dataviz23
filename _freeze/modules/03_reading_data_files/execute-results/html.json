{
  "hash": "558b8ffc9138aa2d3841d35938aff512",
  "result": {
    "markdown": "---\ntitle: \"**Reading data files**\"\nauthor: \"Gabriel I. Cook\"\n#date: \"2023-09-19\"\ndate: \"19 September, 2023\"\n\nexecute:\n  #enabled: false\n  freeze: auto\n# this is a test to fingure out why there is the following error when rendering many quarto files:\n# ERROR: The filename, directory name, or volume label syntax is incorrect. (os error 123)\n---\n\n\n::: callout-important\n## Under construction. \n\nThis page is a work in progress and may contain areas that need more detail or that required syntactical, grammatical, and typographical changes. If you find some part requiring some editing, please let me know so I can fix it for you.\n\n:::\n\n\n\n\n\n\n# **Overview**\n\nIn this module, you will learn how to read and write data files in different formats. Depending how you access data, the process may change so this topic is discussed in a general way with different approaches described. If you find yourself in a bind with reading data, one of these approaches will likely work. In many instances, however, `readr::read_csv()` will be your friend when reading files and `readr::write_csv()` will be for writing files.\n\nIn addition, concepts related to reading files and managing workflow are discussed. By doing so, my goal is to make you aware of some key issues that could cause some problems with data science projects. When reading files, \n\n\n# **To Do**\n\n## **Readings**\n\n- [R Workflow Basics](https://r4ds.had.co.nz/workflow-basics.html)\n- [General Wrangling: Sections 5.1 up through 5.5](https://r4ds.had.co.nz/transform.html#introduction-2)\n\n\n## **Task**\n- [Create a GitHub account](https://github.com/) if you don’t have one (this may come in handy for projects and a blog if you want)\n\n\n## **Libraries** \n\n- **{openxlsx}** 4.2.5.2: for reading Excel spreadsheets from a URL\n- **{readxl}** 1.4.3: for reading Excel spreadsheets\n- **{readr}** 2.1.4: for reading `.csv`, `.tsv`, and `.fwf` files\n\n\nFirst, we need an `.xlsx` data file. You can obtain one locally or online from a URL. \n\n\n# **Downloading a `.zip` File from a URL**\n\nGitHub handles Excel files in a way that makes downloading them challenging, so we will first download a `.zip` file containing the `.xlxs` file. \n\nYou can accomplish this in two ways:\n\n- Download from [here](https://github.com/slicesofdata/dataviz23/raw/main/data/cms-top-all-time-2023-swim.zip), save in your project `/data` directory, and unzip\n\n- Use the URL to a zip file and download to the project `/data` directory, unzip the contents, and remove the `.zip` file using the code below\n\n\n::: {.cell}\n\n```{.r .cell-code}\nzip_url <- \"https://github.com/slicesofdata/dataviz23/raw/main/data/cms-top-all-time-2023-swim.zip\"\n\ndownload.file(zip_url, destfile = here::here(\"data\", \"swim.zip\"))\nunzip(here::here(\"data\", \"swim.zip\"), \n      overwrite = TRUE, \n      exdir = here::here(\"data\")\n      )\n\nfile.remove(here::here(\"data\", \"swim.zip\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nIf the process worked correctly, the file should exist in the directory.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfile.exists(here::here(\"data\", \"cms-top-all-time-2023-swim.xlsx\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nOK, great! Let's move to importing files more generally.\n\n\n# **Reading/Importing Data Files**\n\n## **Excel files from a URL**\n\n**{readxl}** 1.4.3 lacks the ability to read the file from online. We can, however, read it using **{openxlsx}**. The problem is that you will only be able to read a the first sheet. If the first sheet is all you need, this can work. Pass the URL to `openxlsx::read.xlsx()` and assign it's contents to an object named `DAT` using the assignment operator `<-`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nURL <- \"https://github.com/slicesofdata/dataviz23/raw/main/data/cms-top-all-time-2023-swim.xlsx\"\n\nDAT <- openxlsx::read.xlsx(URL, sheet = 1)\n```\n:::\n\n\nWhat does the head of the data file look like?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(DAT)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   score              name year          event   team\n1 525.35       Maia Presti 2015 1-Meter Diving Athena\n2 514.70 Makenna Parkinson 2023 1-Meter Diving Athena\n3 512.05      Emma Ng Pack 2023 1-Meter Diving Athena\n4 494.95         Izzy Doud 2023 1-Meter Diving Athena\n5 462.15     Carli Lessard 2015 1-Meter Diving Athena\n6 447.70     Alexis Romero 2023 1-Meter Diving Athena\n```\n:::\n:::\n\n\nJust an FYI, when you want a different worksheet you will need to pass a sheet name to the `sheet` argument. In this case, we saved it as part of the download process. Let's pass `sheet = \"swim\"`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(\n  openxlsx::read.xlsx(URL, sheet = \"swim\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   time             name year   event   team\n1 23.29 Jocelyn Crawford 2019 50 FREE Athena\n2 23.31    Ava Sealander 2022 50 FREE Athena\n3 23.49        Kelly Ngo 2016 50 FREE Athena\n4 23.71        Helen Liu 2014 50 FREE Athena\n5 23.76      Michele Kee 2014 50 FREE Athena\n6 23.77 Natalia Orbach-M 2020 50 FREE Athena\n```\n:::\n:::\n\n\n\n## **Reading Excel Spreadsheets with `{readxl}`**\n\nWe will use the **{readxl}** library to handing reading of Excel files. Because Excel files can contain multiple sheets, one goal would be to find out the sheet names using `readxl::excel_sheets` (see `?readxl::excel_sheets`). This function takes one argument, which is the path to the file. Passing the path will return the sheet names in that file. We can pass the path string directly into the function or if the file path is already saved as a object, pass that. \n\nIn order to read an Excel spreadsheet file, you will need to specify at very least `file` and if you want to read a specific sheet other than the first one, then you will need to specify `sheet`.\n\n-  `file`: a path to the file, including the file name\n-  `sheet`: the sheet name to read\n\n\n### **Getting Sheet Names**\n\nFirst, let's assign the file path to an object because we will use this path a few times and we don't want to keep typing it lest we make an error.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfile_name <- \"cms-top-all-time-2023-swim.xlsx\"\n```\n:::\n\n\nWe can examine the worksheet names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreadxl::excel_sheets(path = here::here(\"data\", file_name))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"diving\" \"swim\"   \"relay\" \n```\n:::\n:::\n\n\nGreat, we know know the sheet names. The benefit of passing an object is that you you may wish to pass the path to another function, for example, to read a sheet from the file. \n\n\n### **Reading a Sheet**\n\nIn order to read a sheet, we will use `readxl::read_excel()`, which takes the file `path` as the first argument and the name of the desired `sheet` as the second argument. You might get away with passing only the `path` as long as your goal is to read the first sheet because this is the default action. Let's wrap the function in `head()` to see the top.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(\n  readxl::read_excel(here::here(\"data\", file_name))\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n  score  name              year  event          team  \n  <chr>  <chr>             <chr> <chr>          <chr> \n1 525.35 Maia Presti       2015  1-Meter Diving Athena\n2 514.70 Makenna Parkinson 2023  1-Meter Diving Athena\n3 512.05 Emma Ng Pack      2023  1-Meter Diving Athena\n4 494.95 Izzy Doud         2023  1-Meter Diving Athena\n5 462.15 Carli Lessard     2015  1-Meter Diving Athena\n6 447.70 Alexis Romero     2023  1-Meter Diving Athena\n```\n:::\n:::\n\n\nThe function also turns the file content into special object type knows as a `data frame`. A data frame is composed of row and column data. Sometimes data frames are messy but luckily we have a fairly clean file. You can verify using `R`'s built-in function `is.data.frame()`, which will return `TRUE` if it's a data frame or `FALSE` if not.\nWe will assign this to an object \n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.data.frame(readxl::read_excel(here::here(\"data\", file_name)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nBut we don't want the first sheet. Pass `sheet = \"swim\"` to read that sheet. Also, let's read in the data and assign it to an object called `DAT` which will hold the data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT <- readxl::read_excel(here::here(\"data\", file_name), sheet = \"swim\")\n```\n:::\n\n\nViewing the head of the data frame, we can see that it is composed of 5 column vectors representing variables with names: time, name, year, event, team. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(DAT)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n  time  name             year  event   team  \n  <chr> <chr>            <chr> <chr>   <chr> \n1 23.29 Jocelyn Crawford 2019  50 FREE Athena\n2 23.31 Ava Sealander    2022  50 FREE Athena\n3 23.49 Kelly Ngo        2016  50 FREE Athena\n4 23.71 Helen Liu        2014  50 FREE Athena\n5 23.76 Michele Kee      2014  50 FREE Athena\n6 23.77 Natalia Orbach-M 2020  50 FREE Athena\n```\n:::\n:::\n\n\nOK, that was fun. In order to demonstrate reading local `.csv` files, we will take a detour into saving files.\n\n\n\n# **Writing/Exporting Data Files**\n\nDespite it's name, **{readr}** can save data frames too. Interestingly, at least at the time of this writing, **{readr}** allows you to write files in excel format even though you cannot open them. \n\nMoving forward, you can save the data frame as a `.csv` file using `readr::write_csv()`. When writing a file using `write_csv()` we need to specify key arguments: `x`, the data frame object, and `file`, the file name. You do not need to set a delimiter because, given its name, `.csv` defaults the separation as a comma `\",\"`. Other arguments may be necessary for other files and goals. \n\nIf, however, you specify name of the file (e.g., `\"my file name.csv\"`), the data frame will be written to a default location because no file path was provided. Um, so where is that default location? Well it depends and it's complicated depending on whether files are `.R` or `.Rmd`. By default, `.Rmd` files will assume the directory from which the `.Rmd` file, NOT THE DATA FILE, is opened. But you don't want to save a data file to the directory where your code lives. \n\nIf you are organized, you save your `.R` and `.Rmd` files in code directory and your data files in a data directory. So yeah, the default is a problem. The solution is to specify the file path using `file = the file path`. \n\n\n## **Managing file paths with {here}**\n\nWhen downloading the file, you may have noticed using the **{here}** library. A discussion of the library was delayed at the time. We will now look a little deeper into how the library simplifies working with file paths within the context of the **{readr}**.\n\nWhat's the best way to handle directories and file paths? Undoutedly, that is the **{here}** library, assuming of course you are smart enough to be using projects in `RStudio`. When you open a file from within a project, **{here}** will make the project directory the working directory. And if you are organized, your data files will be in a `/data` directory inside the project directory. When passing `\"data\"` as the first argument to `here::here()` ( e.g., `here::here(\"data\")`, you will see that the function returns a string containing the full path to the project directory plus the data subdirectory. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nhere::here(\"data\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"C:/Users/gcook/Sync/git/dataviz23/data\"\n```\n:::\n:::\n\n\n\n# **Writing with {readr}**\n\nData frames can be written, or saved, as `.csv` files using `readr::write_csv()`, as r data files using `readr::write_rds()`, as Excel `.csv` files using `readr::write_excel_csv()`, as well as other formats. \n\nIf you query `R` using `?readr::write_excel_csv` or `?write_excel_csv` having already loaded **{readr}** using `library(readr)`, you will see the arguments. \n\n\n\n\n\nOK, so let's save the data frame. But remember, you cannot pass the file path and name used to read the `.xlsx` file because the data frame you  want to save is not in `.xlsx` file format. \n\nIf you pass that previous path string (cms-top-all-time-2023-swim.xlsx ), you will overwrite that existing Excel file, which likely is not your end goal for at least two reasons. First, the `.csv` would be incorrectly named as `.xlsx` and second, you would completely clobber your Excel spreadsheet along with all of the other worksheets that you did not read. Yeah, that would be bad.\n\nSo we need to change the file name. Specifically, we only need to change the file extension part of the path. We could simply copy and paste the path and change `\".xlsx\"` to `\".csv\"`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nreadr::write_csv(DAT, here::here(\"data\", \"cms-top-all-time-2023-swim.csv\"))\n```\n:::\n\n\nSure, that will work. But I would also like you to think about smart workflow.\n\n\n## **A Workflow Side Note on Strings**\n\nYou could avoid hard coding the change of the file extension in order to streamline you workflow. Every time to pass the path and the path changes you will need to change this by hand and doing so could be extremely annoying. For example, if you change the save location or the file name, you'll need to make updates for all code referencing the path. To avoid potential headaches, we can instead use `gsub()` to examine a string, look for a pattern, and replace that pattern with another pattern. All we want to do is to change `\".xlsx\"` or `\".xls\"` in the string to `\".csv\"`. And because we will next want to use this new name for reading later, let's assign the change to a new string object, `file_csv`.\n\nFirst, let's see what `gsub()` is doing.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngsub(pattern = \".xlsx|.xls\",  \n     replacement = \".csv\", \n     x = file_name\n     )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"cms-top-all-time-2023-swim.csv\"\n```\n:::\n:::\n\n\nAssign to an object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfile_csv <- gsub(\".xlsx|.xls\", \".csv\", file_name)\n```\n:::\n\n\nNote: Code was simplified because the arguments were passed in the order expected by the `gsub()` function.\n\n\nSecond, pass the path object to `write_csv()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreadr::write_csv(x = DAT, \n                 file = here::here(\"data\", file_csv)\n                 )\n```\n:::\n\n\nDid it save? Use `file.exists()`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nfile.exists(here::here(\"data\", file_csv))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nRemember, all we have done is save the data frame. This new file will contain only the data from the spreadsheet that we read earlier. Before opening this new file, we need to take a detour on general handling of reading files with **{readr}**.\n\n\n# **Reading `.csv` files with {readr}**\n\nThe `base R` functions for reading/importing and writing/exporting data can be slow and may cause issues on different operating systems. By contrast, **{readr}** functions operate independently of the OS. As a result, we will generally use the **{readr}** equivalent to `read.csv` files is `readr::read_csv()` (note the library reference and function name).\n\nIf you query `R` using `?readr::read_csv` or `read_csv` having already loaded  the **{readr}** library using `library(readr)`, you will see how to use the function.\n\n\n\n\n\nIn order to read a data file, you will need to specify at very least `file`, which could be a physical file or a remote file. We will address a few ways of reading data.\n\n-  `file`: a path to a file, a connection, or literal data (either a single string or a raw vector)\n-  `delim = \" \"`: the delimiter used to separate values; this is `\",\"` for `.csv` files\n-  `col_names = !append`: the names of columns/variables\n\nSome examples:\n\n- Reading a `.csv` file from a website\n- Reading a locale `.csv` file\n- Reading raw data that is comma-separated\n\n\n## **Reading a `.csv` File Stored on a Website**\n\nFor example, although the `mtcars` data is also a built-in data set in `R`, if it were a read actual `.csv` file save on some website, you can pass the URL path as the `file`. This file does exist on the **{tidyverse}** github for `{readr}`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nreadr::read_csv(file = \"https://github.com/tidyverse/readr/raw/main/inst/extdata/mtcars.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 32 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (11): mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 32 × 11\n     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4\n 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n# ℹ 22 more rows\n```\n:::\n:::\n\n\nBecause `file` if the first argument of the function, you do not need to reference it specifically. Doing so just eliminates ambiguity for more complicated function calls. You will come across a lot of examples of code that do NOT reference the arguments by name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreadr::read_csv(\"https://github.com/tidyverse/readr/raw/main/inst/extdata/mtcars.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 32 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (11): mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 32 × 11\n     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4\n 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n# ℹ 22 more rows\n```\n:::\n:::\n\n\nBy default, `readr::read_csv()` tries to guess whether column/variable names are present. If you know they exist, you can set `col_names = TRUE`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nreadr::read_csv(\"https://github.com/tidyverse/readr/raw/main/inst/extdata/mtcars.csv\", col_names = T)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 32 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (11): mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 32 × 11\n     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4\n 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n# ℹ 22 more rows\n```\n:::\n:::\n\n\nIf the names are present and you set  `col_names = FALSE`, you will get a mess because **{readr}** will assume the header row is data just as the rest of the file.\n \n\n::: {.cell}\n\n```{.r .cell-code}\nreadr::read_csv(\"https://github.com/tidyverse/readr/raw/main/inst/extdata/mtcars.csv\", col_names = F)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 33 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (11): X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 33 × 11\n   X1    X2    X3    X4    X5    X6    X7    X8    X9    X10   X11  \n   <chr> <chr> <chr> <chr> <chr> <chr> <chr> <chr> <chr> <chr> <chr>\n 1 mpg   cyl   disp  hp    drat  wt    qsec  vs    am    gear  carb \n 2 21    6     160   110   3.9   2.62  16.46 0     1     4     4    \n 3 21    6     160   110   3.9   2.875 17.02 0     1     4     4    \n 4 22.8  4     108   93    3.85  2.32  18.61 1     1     4     1    \n 5 21.4  6     258   110   3.08  3.215 19.44 1     0     3     1    \n 6 18.7  8     360   175   3.15  3.44  17.02 0     0     3     2    \n 7 18.1  6     225   105   2.76  3.46  20.22 1     0     3     1    \n 8 14.3  8     360   245   3.21  3.57  15.84 0     0     3     4    \n 9 24.4  4     146.7 62    3.69  3.19  20    1     0     4     2    \n10 22.8  4     140.8 95    3.92  3.15  22.9  1     0     4     2    \n# ℹ 23 more rows\n```\n:::\n:::\n\n\nAs you can see, the column names are all prefixed with \"X\" and the first row is now the name of the headers. `names()` or `colnames()` will return the column names, so we can apply it and see what happens. We will wrap  `readr::read_csv()` in `names()`. See how this is a problem. You can use `colnames()` to test this too.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(\n  readr::read_csv(\"https://github.com/tidyverse/readr/raw/main/inst/extdata/mtcars.csv\", col_names = T)\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 32 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (11): mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"mpg\"  \"cyl\"  \"disp\" \"hp\"   \"drat\" \"wt\"   \"qsec\" \"vs\"   \"am\"   \"gear\"\n[11] \"carb\"\n```\n:::\n:::\n\n\n\n## **Reading a `.csv` File Stored Locally on your Computer**\n\nIf a file actually existed on your computer, the file would not be a URL but rather the path location to where the file is stored.\n\nAnd now we can read the locale file as before except we are not passing the string name but rather an object (e.g., `file_csv`) holding the file path and file name. Voilà.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreadr::read_csv(here::here(\"data\", file_csv))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 440 Columns: 5\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): time, name, year, event, team\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 440 × 5\n   time  name             year  event   team  \n   <chr> <chr>            <chr> <chr>   <chr> \n 1 23.29 Jocelyn Crawford 2019  50 FREE Athena\n 2 23.31 Ava Sealander    2022  50 FREE Athena\n 3 23.49 Kelly Ngo        2016  50 FREE Athena\n 4 23.71 Helen Liu        2014  50 FREE Athena\n 5 23.76 Michele Kee      2014  50 FREE Athena\n 6 23.77 Natalia Orbach-M 2020  50 FREE Athena\n 7 23.77 Suzia Starzyk    2020  50 FREE Athena\n 8 23.87 Katie Bilotti    2010  50 FREE Athena\n 9 23.93 Jenni Rinker     2011  50 FREE Athena\n10 24.02 Annika Sharma    2023  50 FREE Athena\n# ℹ 430 more rows\n```\n:::\n:::\n\n\n\n## **Reading Raw Data that is Comma-Separated (e.g., `.csv`)**\n\nWe will file use `readr::read_csv()` to read our data file (viz., cms-top-all-time-2023-swim.csv). \n\n\n::: {.cell}\n\n```{.r .cell-code}\nreadr::read_csv(here::here(\"data\", file_csv))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 440 Columns: 5\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): time, name, year, event, team\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 440 × 5\n   time  name             year  event   team  \n   <chr> <chr>            <chr> <chr>   <chr> \n 1 23.29 Jocelyn Crawford 2019  50 FREE Athena\n 2 23.31 Ava Sealander    2022  50 FREE Athena\n 3 23.49 Kelly Ngo        2016  50 FREE Athena\n 4 23.71 Helen Liu        2014  50 FREE Athena\n 5 23.76 Michele Kee      2014  50 FREE Athena\n 6 23.77 Natalia Orbach-M 2020  50 FREE Athena\n 7 23.77 Suzia Starzyk    2020  50 FREE Athena\n 8 23.87 Katie Bilotti    2010  50 FREE Athena\n 9 23.93 Jenni Rinker     2011  50 FREE Athena\n10 24.02 Annika Sharma    2023  50 FREE Athena\n# ℹ 430 more rows\n```\n:::\n:::\n\n\nIf there were only data in the file and no names representing variables on the first row, the file might look like that below. We can imitate this by skipping the first row (containing names) using `skip = `. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreadr::read_csv(here::here(\"data\", file_csv), skip = 1)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 439 Columns: 5\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): 23.29, Jocelyn Crawford, 2019, 50 FREE, Athena\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 439 × 5\n   `23.29` `Jocelyn Crawford` `2019` `50 FREE` Athena\n   <chr>   <chr>              <chr>  <chr>     <chr> \n 1 23.31   Ava Sealander      2022   50 FREE   Athena\n 2 23.49   Kelly Ngo          2016   50 FREE   Athena\n 3 23.71   Helen Liu          2014   50 FREE   Athena\n 4 23.76   Michele Kee        2014   50 FREE   Athena\n 5 23.77   Natalia Orbach-M   2020   50 FREE   Athena\n 6 23.77   Suzia Starzyk      2020   50 FREE   Athena\n 7 23.87   Katie Bilotti      2010   50 FREE   Athena\n 8 23.93   Jenni Rinker       2011   50 FREE   Athena\n 9 24.02   Annika Sharma      2023   50 FREE   Athena\n10 51.05   Kelly Ngo          2016   100 FREE  Athena\n# ℹ 429 more rows\n```\n:::\n:::\n\n\nSee how the first row is assumed to be *names*? Setting `col_names = F` will fix the problem. Putting the arguments on separate rows of `R` code might improve code legibility.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreadr::read_csv(here::here(\"data\", file_csv), \n                skip = 1,\n                col_names = F\n                )\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 440 Columns: 5\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): X1, X2, X3, X4, X5\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 440 × 5\n   X1    X2               X3    X4      X5    \n   <chr> <chr>            <chr> <chr>   <chr> \n 1 23.29 Jocelyn Crawford 2019  50 FREE Athena\n 2 23.31 Ava Sealander    2022  50 FREE Athena\n 3 23.49 Kelly Ngo        2016  50 FREE Athena\n 4 23.71 Helen Liu        2014  50 FREE Athena\n 5 23.76 Michele Kee      2014  50 FREE Athena\n 6 23.77 Natalia Orbach-M 2020  50 FREE Athena\n 7 23.77 Suzia Starzyk    2020  50 FREE Athena\n 8 23.87 Katie Bilotti    2010  50 FREE Athena\n 9 23.93 Jenni Rinker     2011  50 FREE Athena\n10 24.02 Annika Sharma    2023  50 FREE Athena\n# ℹ 430 more rows\n```\n:::\n:::\n\n\nBut we have no column names now. Setting `col_names = ` will fix that. Use `c()` to combine 4 names, e.g.,  `col_names = c(\"name1\", \"name2\", \"name3\", \"name4\")`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreadr::read_csv(here::here(\"data\", file_csv), \n                skip = 1,\n                col_names = c(\"time\", \"name\", \"year\", \"event\")\n                )\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 440 Columns: 5\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): time, name, year, event, X5\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 440 × 5\n   time  name             year  event   X5    \n   <chr> <chr>            <chr> <chr>   <chr> \n 1 23.29 Jocelyn Crawford 2019  50 FREE Athena\n 2 23.31 Ava Sealander    2022  50 FREE Athena\n 3 23.49 Kelly Ngo        2016  50 FREE Athena\n 4 23.71 Helen Liu        2014  50 FREE Athena\n 5 23.76 Michele Kee      2014  50 FREE Athena\n 6 23.77 Natalia Orbach-M 2020  50 FREE Athena\n 7 23.77 Suzia Starzyk    2020  50 FREE Athena\n 8 23.87 Katie Bilotti    2010  50 FREE Athena\n 9 23.93 Jenni Rinker     2011  50 FREE Athena\n10 24.02 Annika Sharma    2023  50 FREE Athena\n# ℹ 430 more rows\n```\n:::\n:::\n\n\nIf you have column names that are on row 1 of the data frame, don't skip that row and instead set `col_names = TRUE` to put them in place. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nreadr::read_csv(here::here(\"data\", file_csv), \n                col_names = T\n                )\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 440 Columns: 5\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): time, name, year, event, team\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 440 × 5\n   time  name             year  event   team  \n   <chr> <chr>            <chr> <chr>   <chr> \n 1 23.29 Jocelyn Crawford 2019  50 FREE Athena\n 2 23.31 Ava Sealander    2022  50 FREE Athena\n 3 23.49 Kelly Ngo        2016  50 FREE Athena\n 4 23.71 Helen Liu        2014  50 FREE Athena\n 5 23.76 Michele Kee      2014  50 FREE Athena\n 6 23.77 Natalia Orbach-M 2020  50 FREE Athena\n 7 23.77 Suzia Starzyk    2020  50 FREE Athena\n 8 23.87 Katie Bilotti    2010  50 FREE Athena\n 9 23.93 Jenni Rinker     2011  50 FREE Athena\n10 24.02 Annika Sharma    2023  50 FREE Athena\n# ℹ 430 more rows\n```\n:::\n:::\n\nLuckily, we have both names and data in the file and by default `readr::read_csv()` does what we intend.\n\n\n\n## **Reading Data from a Library/Package**\n\nAs mentioned earlier, `mtcars` is a data set on cars which is also part of base `R`, meaning you do not need to read it from anyplace. `R` does this automatically.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n```\n:::\n\n```{.r .cell-code}\n# or \nprint(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n```\n:::\n:::\n\n\nUse `names()` to read the column names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"mpg\"  \"cyl\"  \"disp\" \"hp\"   \"drat\" \"wt\"   \"qsec\" \"vs\"   \"am\"   \"gear\"\n[11] \"carb\"\n```\n:::\n:::\n\n\n\n# **Assigning a Data Frame to an Object** \n\nUnfortunately, once you read data into `R` what you see is only the returned content from the functions. This approach will not really allow you to perform other operations on the data frame itself very easily because you would have to read the file over and over every time you wished to perform a different operation. \n\n\n## **Object Assignment using `<-`**\n\nYou will want to take the data frame object that is returned by the `read.csv()` function and assign it to an object of some name using the assignment operator `<-` . Although the concept of assignment will be covered later, for now just understand that we need to make the data more accessible to work with. You could name the object anything you want. Let's assign it to `DAT` standing for `data frame` and let's make it ALL CAPS. \n\nA note about case: `R` is a case-sensitive language so object names like `DAT`, `dat`, `DaT`, etc. are possible and can refer to different objects depending on how you assign them. We will use capital letters only because I like to flag objects that are data frame as special and this approach makes them visually identifiable. You could choose your own convention for naming data frames, other objects, variables in data frames, etc. but I don't recommend being random about it.\n\n\n## Using `read.table()`:\n\n`read.table()` is a flexible function for reading files because you can specify how the data are separated in rows by setting the `sep` argument. A common separation is a comma but you might also have tabs or other special characters. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT <- read.table(file = here::here(\"data\", file_csv),\n                  sep = \",\",\n                  header = T\n                  )\n```\n:::\n\n\n`read.csv()` is a specific case of `read.table()` that sets `sep = \",\"` for you so there is no need to pass the argument. `read.csv()` is the more common function you will come across for reading `.csv` files but `read.table()` works the same as long as you set the argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT <- read.csv(here::here(\"data\", file_csv))\n```\n:::\n\n\n## Using `read_csv()` from **{readr}**:\n\nThere are advantages to using `readr::read_csv()` over `read.csv()`, which is why we will prefer it. We will assign it to an object named `DAT2`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT2 <- readr::read_csv(here::here(\"data\", file_csv))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 440 Columns: 5\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): time, name, year, event, team\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\nhead(DAT2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n  time  name             year  event   team  \n  <chr> <chr>            <chr> <chr>   <chr> \n1 23.29 Jocelyn Crawford 2019  50 FREE Athena\n2 23.31 Ava Sealander    2022  50 FREE Athena\n3 23.49 Kelly Ngo        2016  50 FREE Athena\n4 23.71 Helen Liu        2014  50 FREE Athena\n5 23.76 Michele Kee      2014  50 FREE Athena\n6 23.77 Natalia Orbach-M 2020  50 FREE Athena\n```\n:::\n:::\n\n\nWe can test whether `DAT` and `DAT2` are the same using a logical test `==`. Notice the two `=`. If we use one `=`, we will actually assign the contents of `DAT2` to `DAT` because a single `=` in this context (scope) will do the same as `<-`. A discussion of the differences is beyond the scope here but suffice it so say `<-` is the common practice except when you are writing custom functions. In most cases, assignment inside functions are done with `=` because objects created inside a function are not typically needed outside that scope.\n\nAnyway, you can see that the contents are the same even when files are read by different functions. This is wrapped in the `all()` function, which will return `TRUE` if everything is `TRUE`. This is good that the contents are identical.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall(DAT == DAT2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n\n## **Data as a Data Frame**\n\nYou should see an object named `DAT` that contains the data frame with some swim data. If you want to verify this is actually a data frame object, you can pass the `DAT` object into the `is.data.frame()` function. The function will return `TRUE` if it is and `FALSE` if it is not.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.data.frame(DAT)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.data.frame(DAT2)  # tibbles are also data frames\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n\n## **Are they both `tibbles`?**\n\nTibbles are different from data frames, see the [**{tibble}** library](https://cran.r-project.org/web/packages/tibble/vignettes/tibble.html).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble::is_tibble(DAT)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\ntibble::is_tibble(DAT2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nNow the you have the data frame, you can examine some of its contents, for example, the first 6 rows using the `head()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(DAT)    # hmm, something seems off.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   time             name year   event   team\n1 23.29 Jocelyn Crawford 2019 50 FREE Athena\n2 23.31    Ava Sealander 2022 50 FREE Athena\n3 23.49        Kelly Ngo 2016 50 FREE Athena\n4 23.71        Helen Liu 2014 50 FREE Athena\n5 23.76      Michele Kee 2014 50 FREE Athena\n6 23.77 Natalia Orbach-M 2020 50 FREE Athena\n```\n:::\n:::\n\n\nBecause header rows do exist atop the `.csv` file, specify that they exist by passing `TRUE` to the `header` argument of the function (e.g., `header = TRUE` or `header = T`). \n\n\n::: {.cell}\n\n```{.r .cell-code}\nDAT <- read.table(here::here(\"data\", file_csv),\n                  sep = \",\", \n                  header = TRUE\n                  )\n\nhead(DAT)    # Perfect!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   time             name year   event   team\n1 23.29 Jocelyn Crawford 2019 50 FREE Athena\n2 23.31    Ava Sealander 2022 50 FREE Athena\n3 23.49        Kelly Ngo 2016 50 FREE Athena\n4 23.71        Helen Liu 2014 50 FREE Athena\n5 23.76      Michele Kee 2014 50 FREE Athena\n6 23.77 Natalia Orbach-M 2020 50 FREE Athena\n```\n:::\n:::\n\n\n\n# **Project Organization**\n\nFor many projects, you will have to perform lots of data cleaning. For those instances, you would likely also want to organize your project in a way that you create dedicated `.R` used to read and clean the data. Depending on circumstances, you may also wish to create one file for reading data and one for cleaning. You would also have separate files for running analyses or for creating plots. In your report file, you would include a code block for sourcing other scripts as shown here. \n\n```\nsource(here::here(\"r\", \"read_data.R\"))\nsource(here::here(\"r\", \"clean_data.R\"))\nsource(here::here(\"r\", \"analyze_data.R\"))\nsource(here::here(\"r\", \"create_plots.R\"))\n```\n\nThe alternative is that you write all of your code in one file and overwhelm yourself because of all of the lines of code. You could, however, think of yourself as members of a team and organize your files as though you were working with others.  \n\nWhen working with teams, you would likely also manage a [github](https://github.com/) repository for your project. Team contributors would be working on separate tasks and separate files. The files might be used by one or all team members. You could imagine how difficult the process would be if there was only one file with all project code. Whether you manage a repo for your project or you do not, be smart and compartmentalize your code into meaningful chunks. \n\n\n# **Reading Large Files**\n\nNow, sometimes you might work with very large files over 1 GB in size. If so, `read.csv()` and `read.table()` will be extremely slow. You'll want another function. One of the fastest is `fread()` that is part of a library that's not built into base R. The library is **{data.table}**. **{vroom}** is a new library that may even be better. See [{vroom}](https://cran.r-project.org/web/packages/vroom/vignettes/vroom.html).\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}