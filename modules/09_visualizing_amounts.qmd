---
title: "**Visualizing amounts**"
author: "Gabriel I. Cook"
#date: "`r Sys.Date()`"
date: "`r format(Sys.time(), '%d %B, %Y')`"

# this is a test to fingure out why there is the following error when rendering many quarto files:
# ERROR: The filename, directory name, or volume label syntax is incorrect. (os error 123)
---

```{r}
#| label: load-packages
#| include: false


```

::: callout-important
## Under construction. 

This page is a work in progress and may contain areas that need more detail or that required syntactical, grammatical, and typographical changes. If you find some part requiring some editing, please let me know so I can fix it for you.

:::

# **Overview**

This module demonstrates some ways to visualize amounts or quantities. 

There are a few key concerns for any data presentation. First, you need to determine what data you want to present. Second, you must to determine how the user will use that information presented. For example, will they make comparisons and if so, what kind of comparisons will they make? The more complicated the data presented, the more comparisons can be made of course. Third, you must consider the interaction between the two, in essence how the data visualization may affect the goal the user has in mind. If you intend users to make a particular comparison, you want to present your data in a way that facilitates that process rather than hinder that process. 
Amounts could be presented in tabular form for instance when actual values are essential. Amounts could also be presented in visual form as a graphic of some form. Depending on the goals or the use of the data, creating separate plots that facilitate the interpretation process may be most optimal when the bias of the user competes with the aesthetic elements of the visualization (e.g., Gestalt principles).

A sub goal of the module is also to understand how to map variables in a data frame to geoms and corresponding aesthetics using **{ggplot2}**.


# **To Do**


## **Readings**

Reading should take place in two parts:

 - *Prior to class*, the goal should be to familiarize yourself and bring questions to class. The readings from [TFDV](https://clauswilke.com/dataviz) are conceptual and should facilitate readings from [EGDA](https://ggplot2-book.org/) for code implementation.
 - *After class*, the goal of reading should be to understand and implement code functions as well as support your understanding and help your troubleshooting of problems. 

*Before Class*: First, read to familiarize yourself with the concepts rather than master them. Understand why one would want to visualize data in a particular way and also understand some of the functionality of **{ggplot2}**. I will assume that you attend class with some level of basic understanding of concepts.

*Class*: In class, some functions and concepts will be introduced and we will practice implementing **{ggplot2}** code. On occasion, there will be an assessment involving code identification, correction, explanation, etc. of concepts addressed in previous modules and perhaps some conceptual elements from this week's readings. 

*After Class*: After having some hands-on experience with coding in class, homework assignments will involve writing your own code to address some problem. These problems will be more complex, will involving problem solving, and may be open ended. This is where the second pass at reading with come in for you to reference when writing your code. The module content presented below is designed to offer you some assistance working through various coding problems but may not always suffice as a replacement for the readings from **Wickham, Navarro, & Pedersen (under revision)**. *ggplot2: Elegant Graphics for Data Analysis (3e)*.

- [Wilke (2019). *Fundamentals of Data Visualization*. Directory of visualizations](https://clauswilke.com/dataviz/directory-of-visualizations.html)
- [Wilke (2019). *Fundamentals of Data Visualization*. Visualizing Amounts](https://clauswilke.com/dataviz/visualizing-amounts.html)


## **Libraries** 

- **{here}**: `r packageVersion("here")`: for path management
- **{dplyr}** `r packageVersion("dplyr")`: for selecting, filtering, and mutating
- **{magrittr}** `r packageVersion("magrittr")`: for code clarity and piping data frame objects
- **{ggplot2}**: `r packageVersion("ggplot2")`: for creating data visualization


## **External Functions**

Provided in class:

`view_html()`: for viewing data frames in html format, from `/r/my_functions.R`

```{r}
source(here::here("r", "my_functions.R"))
```

# **Loading Libraries**

We will work with a few different libraries for data manipulation. Let's load them into our work space using `library()`.

```{r message=FALSE}
library(magrittr)
library(dplyr)
library(stringr)
library(ggplot2)
```

*Note:* Make note of any warnings that appear when loading libraries. There are some libraries that contain functions with the same names. Be aware that the most recently loaded library function will take precedence. You can avoid confusion using `::` to call a function from a particular library (e.g., `libraryname::functionname()`).


# **Loading Data**

```{r}
SWIM <- readr::read_csv(
  here::here("data", "cleaned-cms-top-all-time-2023-swim.csv"))
```

Changing the names to title case can facilitate differentiating types of objects, in this case, column variables in a data frame from a data frame, plot, string, function, or something else.

```{r}
names(SWIM) <- tools::toTitleCase(names(SWIM))
```

Take a look:

```{r}
#view_html(SWIM)
```

Take a glimpse:

```{r}
SWIM %>% 
  glimpse(.) 
```


Group by `Event` and take a glimpse:

```{r}
SWIM %>% 
  group_by(., Event) %>%
  glimpse(.) 
```



# **Making some plots**

Based on the data, there are all different types of way to plot amounts even when there are limited variables. More complex data frames will offer more possibilities. Nevertheless, we can create plots bars based on a single metric or bars that stack based on multiple metrics, bars that are not stacked, points, etc. Amounts could be based on variables visibly present in the data frame or involve creating new variables or statistical transformations. For example, amounts to be time, counts, percentages, etc. 

# **Plotting Counts**

We can take the count of various events in order to plot the amount of something. But what fun would an initial example be if it did not introduce a new function? `dplyr::slice()` is a function that allows you to index rows so that you can select, remove, or duplicate rows. For more information, see `?slice`.

Let's say we want to plot the number of instances for which an ultimate best occurred in a given year. The data set contains bests for each year rather than best times across history. So for each event, we can figure out which year had the fastest time and count the number of instances per year. Then, using that data frame, we can create a data visualization that communicates the number of all-time-bests across the years.

How many years are in the data? 

```{r}
length(SWIM$Year)
```

Um, that's too many years. Let's get `unique()` instances.

```{r}
length(unique(SWIM$Year))
```

OK, so we are dealing with a total number of `r length(unique(SWIM$Year))` years for Stag and Athena data. We could also examine the number of events per year but that involves more wrangling, so let's make the assumption that the number of swim `Events` is constant. Let's also assume that the `Time` variable is cleaned up correctly or the plots will be inaccurate given the data. We will not wrangle here but you should make note of whether everything looks accurate.


## **Reduce the data frame to contain the bests**

We will group the data by `Event` and `slice()` the data so that the data frame contains rows that represent the fastest `Time` per event. The `which.min()` function will return the row in an `Event` that contains the lowest value for the variable, `Time`. 

We start with `r dim(SWIM)[1]` rows. 

```{r}
dim(SWIM)
```

```{r}
SWIM %>% 
  group_by(., Event) %>% 
  slice(., which.min(Time)) 
```


Let's assign the new data frame to an object:

```{r}
FAST_BY_EVENT <- SWIM %>% 
  group_by(., Event) %>% 
  slice(., which.min(Time)) 


FAST_BY_EVENT %>% glimpse(.)
```


We now have a data frame containing `r dim(FAST_BY_EVENT)[1]` rows.



## **Data in Tabular Form**

There are many ways to present tabular data. **{htmlTable}** and **{knitr}** as well as other make this easy. For now, we will pass the data frame to `htmlTable::htmlTable()`.

```{r}
FAST_BY_EVENT %>% 
  knitr::kable() #%>% 
  #htmlTable::htmlTable()
```

Selecting only the `Event` and the `Year`:

```{r}
FAST_BY_EVENT %>% 
  select(., Event, Year) %>% 
  knitr::kable() #%>% 
  #htmlTable::htmlTable()
```

Selecting only the `Event` and the `Name`:

```{r}
FAST_BY_EVENT %>% 
  select(., Event, Name) %>% 
  knitr::kable() #%>% 
  #htmlTable::htmlTable()
```

The tables show the best `Year` and the best athlete per event. 


## **Bar Charts**

Perhaps a table is not what you want. Perhaps you want to present data as bars. There are two types of bar chart geometry functions: `geom_bar()` and `geom_col()`. `geom_bar()` takes either an x or a y (not both) and produces a plot for which the height of the bar is proportional to the count/frequency of cases in the vector. By contrast, `geom_col()` takes both an x and a y and plots the height of each x variable bar relative to the value of the y variable. If you want the heights of the bars to represent values in the data (e.g., "identity"), use `geom_col()`. 

### **`geom_bar()`**

```
geom_bar(
  mapping = NULL,
  data = NULL,
  stat = "count",
  position = "stack",
  ...,
  just = 0.5,
  width = NULL,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
```

Trying out `geom_bar()`, we need an either an x or a y aesthetic mapping but not both. When passing a variable to x, the bar will be vertical and when passing the variable to y, the bar will be horizontal. Because the mapping is inherited from `ggplot()` if specified there, you will throw an error like the following because both x and y will be inherited. 

Using `%>%`, we will pass the data frame to `ggplot()`:

```
SWIM %>%
  ggplot(., aes(x = Year, y = Time)) +
  geom_bar()
```

```
Error in f(): ! stat_count() can only have an x or y aesthetic.
```

We can change the mapping in the base `ggplot()` layer, which will plot bars corresponding to the unique levels of the variable passed to x at a height relative to the frequency of occurrence of those unique levels. 

Checking `?geom_bar`, you will notice that `geom_bar()` has a default `stat = "count"`. This means that the default bar plot will plot the "count", or frequency, of elements in a vector variable. When the count or frequency of a value is 1, the bar height will be 1 on the y axis and if an element appears 5 times in the vector, the bar height will be 5. For a horizontal bar, the bar length, rather than height, will be 5. Looking at `FAST_BY_EVENT$Team`, you will see many instances that will be "Stag" or "Athena". Based on the previous discussion, what might you expect the bar to look like? Answer before seeing the plot or explain why after seeing the plot.


Let's pass a variable to x:

```{r}
FAST_BY_EVENT %>%
  ggplot(., aes(x = Year)) +
  geom_bar()
```

```{r}
FAST_BY_EVENT %>%
  ggplot(., aes(x = Team)) +
  geom_bar()
```


```{r}
FAST_BY_EVENT %>%
  ggplot(., aes(x = Event)) +
  geom_bar()
```

Messy. I am not sure that's what we want but you get a feel for what `geom_bar()` is doing.


Let's pass a variable to y:

```{r}
FAST_BY_EVENT %>%
  ggplot(., aes(y = Team)) +
  geom_bar()
```


```{r}
FAST_BY_EVENT %>%
  ggplot(., aes(x = Year)) +
  geom_bar()
```

If `geom_bar()` does inherit x and y from `ggplot()`, and if you want the heights of the bars to represent values in the data (e.g., "identity"), use `geom_bar()` and pass `stat = "identity")`. You should see the same plot as shown with passing only `x = Year` except for the inclusion of `Team` information.

```{r}
FAST_BY_EVENT %>%
  ggplot(., aes(x = Year, y = Team)) +
  geom_bar(stat = "identity")
```

This plot is ugly. We will work on fixing this later but or now understand that `geom_bar()` and `geom_col()` differ but can be used to do plot same thing.


### **`geom_col()`**

Remember that `geom_col()` takes both an x and a y and plots the height of each x variable bar relative to the value of the y variable.  

```
geom_col(
  mapping = NULL,
  data = NULL,
  position = "stack",
  ...,
  just = 0.5,
  width = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
```

Being verbose:


```{r}
FAST_BY_EVENT %>%
  ggplot(data = ., 
         mapping = aes(x = Name, y = Time)
  ) +
  geom_col()
```


Trimming some code:

```{r}
FAST_BY_EVENT %>%
  ggplot(., aes(x = Name, y = Time)
  ) +
  geom_col()
```


```{r}
FAST_BY_EVENT %>%
  ggplot(., aes(x = Year, y = Team)) +
  geom_col()
```

```{r}
FAST_BY_EVENT %>%
  ggplot(., aes(Year, Time)) +
  geom_col()
```

Switching x and y:

```{r}
FAST_BY_EVENT %>%
  ggplot(., aes(x = Team, y = Year)) +
  geom_col()
```

Yuck.





## **Adding Layers**

We can take a plot object and add layers that will override defaults. Let's assign the plot to an object to make adding some layers easier, though not necessary.

```{r}
fast_by_event_col <- FAST_BY_EVENT %>%
  ggplot(data = ., 
         mapping = aes(x = Name, y = Time)
  ) +
  geom_col()
```

Add a `coord_*()` layer, specifically `coord_flip()` to flip the coordinates. Take object, and add layer using `+`:

```{r}
fast_by_event_col +
  coord_flip()
```

Add a `theme()` layer:

```{r}
fast_by_event_col +
  coord_flip() +
  theme_minimal() 
```

Add label layers:

```{r}
fast_by_event_col +
  coord_flip() +
  theme_minimal() +
  xlab(" ") +
  ylab("Seconds")
```


# **Dot Plot/Point Plot**

You can also plot amounts as points. We will add an aesthetic here to color code the points by `Team`. 

```{r}
(fast_by_event_point <- FAST_BY_EVENT %>%
  ggplot(data = ., 
         mapping = aes(x = Name, y = Time)
  ) +
  geom_point(aes(color = Team)) +  
  coord_flip() +
  theme_classic() +
  xlab(" ") +
  ylab("Seconds")
)
```


# **Sub-setting for Plots**

Let's just do for each each team by changing the data frame. There are other ways to address this problem but we will cover those topics later.

```{r}
FAST_BY_EVENT_TEAM <- SWIM %>% 
  group_by(., Team, Event) %>% 
  slice(., which.min(Time)) 
```

Filter by `Team` and Plot:

```{r}
(fast_be_event_team_col_sta <- FAST_BY_EVENT_TEAM %>%
  filter(., Team == "Stag") %>%
   ggplot(data = ., 
         mapping = aes(x = Name, y = Time)
  ) +
  geom_col() +  
  coord_flip() +
  theme_classic() +
  xlab(" ") +
  ylab("Seconds") +
  ggtitle("Fastest Stags for their event since ?")
)


(fast_be_event_team_col_ath <- FAST_BY_EVENT_TEAM %>%
    filter(., Team == "Athena") %>%
    ggplot(data = ., 
         mapping = aes(x = Name, y = Time)
    )  +
    geom_col() +  
    coord_flip() +
    theme_classic() +
    xlab(" ") +
    ylab("Seconds") +
    ggtitle("Fastest Athenas for their event since ?")
)
```

# **Getting Counts by Summary**

Let's use **{dplyr}** to help us obtain subgroups.

```{r}
TOP_BY_YEAR <- SWIM %>%
  group_by(., Name, Team) %>%
  summarize(., Count = dplyr::n()) 

head(TOP_BY_YEAR)
```

Filter for a `Team` and plot. Again, using `geom_bar(stat = "identity")` we will plot the actual counts in the data set.

```{r}
TOP_BY_YEAR %>%
  filter(., Team == "Athena") %>%
  ggplot(., aes(x = Name, y = Count)) +
  geom_bar(stat = "identity") +
  coord_flip()
```



# **Year with Highest Bests**

Let's work from the top using the full `SWIM` datat in order to see the full workflow.

1. Group by team and event type
2. Slice the fastest values 
3. Then group this data frame by year
4. Summarize by counting the rows  
5. Arrange in descending order
6. Create the plot object and map some aesthetics 
7. Add a geom layer


```{r}
SWIM %>% 
  group_by(., Team, Event) %>% 
  slice(., which.min(Time)) %>% 
  group_by(., Year) %>%
  summarize(., Count = dplyr::n()) %>%
  arrange(., desc(Count)) %>%
  ggplot(., aes(x = Year, y = Count)) +
  geom_point()
```

Add another geom layer:

```{r}
SWIM %>% 
  group_by(., Team, Event) %>% 
  slice(., which.min(Time)) %>% 
  group_by(., Year) %>%
  summarize(., Count = dplyr::n()) %>%
  arrange(., desc(Count)) %>%
  ggplot(., aes(x = Year, y = Count)) +
  geom_point() +
  geom_col(fill = "gray")
```

Change the geom layer order and add some color:

```{r}
SWIM %>% 
  group_by(., Team, Event) %>% 
  slice(., which.min(Time)) %>% 
  group_by(., Year) %>%
  summarize(., Count = dplyr::n()) %>%
  arrange(., desc(Count)) %>%
  ggplot(., aes(x = Year, y = Count)) +
  geom_col(fill = "gray", col = "green") +
  geom_point(col = "red") 
```


OK, this example is intentionally ugly and likely has different implications for someone who has red-green colorblindness. The point here is to show you a little able plotting amounts. You can also 


# **Lollipop Plot**

A lollipop plot is like a bar plot but has less ink information. It will encode the point position as height. 

In order to see the variables in the data frame, let's create it and then assign it to an object first.

```{r}
DAT <- SWIM %>% 
  group_by(., Team, Event) %>% 
  slice(., which.min(Time)) %>% 
  group_by(., Year) %>%
  summarize(., Count = dplyr::n()) %>%
  arrange(., desc(Count)) 
```

We can use `geom_segment()` to create a line segment from a starting x and y position to an ending x and y position. We can also flip the coordinates if you want horizontal lines.

```{r}
DAT %>%
  ggplot(., aes(x = Year, y = Count)) +
  geom_segment(aes(x = Year, 
                   xend = Year, 
                   y = 0, 
                   yend = Count)) +
  geom_point(size = 4, col = "black") +
  coord_flip()
```


# **Summary**

This module was used to help demonstrate a subset of ways to visualize amounts using `ggplot()*` objects. The examples represent only subset of different plots one could create to communicate amounts visually. In addition, the rendered plots certainly have problems and fixing those problems will be goals of future modules. 


# **Session Information**

```{r}
sessioninfo::session_info()
```
