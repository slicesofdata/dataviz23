---
title: "**Reading, Managing, & Writing Data**"
author: "Gabriel I. Cook"
#date: "`r Sys.Date()`"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  quarto::html_document:
    #backgroundcolor: blue
  #html_document:               
    toc: yes                   # include a table of contents
    number_sections: yes       # enumerate sections flagged with #
    code_folding: show         # allow option to show/hide code

    theme: css/styles.scss
    #theme: cosmo #quartz
    #css: css/home.css
    #fontcolor: black
    #page-layout: full
    #css: [css/nav.css,css/styles.css]
    
#editor_options: 
#  chunk_output_type: console
---



```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, include=FALSE}
#knitr::opts_chunk$set(echo = TRUE)
```

# **Reading Files**

## **Load our libraries**

-   [`here`](https://here.r-lib.org/) will help keep folders organized

-   [`tidyverse`](https://www.tidyverse.org/packages/) is an ecosystem that will load other relevant libraries

    -   `readr` for reading data files

    -   **`dplyr`**s for manipulating data files

    -   `magrittr` for piping or chaining code commands

```{r message=FALSE, warning=FALSE, include=FALSE}
#rm(list = ls(all.names = TRUE))   # remove objects in R
```

# **Reading/Importing Data Files**

As noted in [FODS CH9](https://www.markhuberdatascience.org/_files/ugd/c2b9b6_543ea42a1ea64e32b4440b34ffd71635.pdf), `base R` functions for reading/importing and writing/exporting data can be slow and may cause issues on different operating systems. By contrast, `readr` functions operate independently of the OS. As a result, we will generally use the `readr` equivalent to `read.csv` files is `readr::read_csv()` (note the library reference and function name).

If you query `R` using `?readr::read_csv` or `read_csv` having already loaded the `readr` library using `library(readr)`, you will see how to use the function.

```{r eval=FALSE, include=FALSE}
?readr::read_csv
```

In order to read a data file, you will need to specify at very least `file`, which could be a physical file or a remote file. We will address a few ways.

-   `file`: a path to a file, a connection, or literal data (either a single string or a raw vector)
-   `delim = " "`: the delimiter used to separate values; this is `","` for `.csv` files
-   `col_names = !append`: the names of columns/variables

Some examples:

-   Reading a `.csv` file on a website
-   Reading a locale `.csv` file
-   Reading raw data that is comma-separated

## **Reading a `.csv` File Stored on a Website**

For example, although the `mtcars` data is also a built-in data set in `R`, if it were a read actual `.csv` file save on some website, you can pass the URL path as the `file`. This file does exist on the `tidyverse` github for `readr`.

``` R
readr::read_csv("https://github.com/tidyverse/readr/raw/main/inst/extdata/mtcars.csv")
```

Because `file` if the first argument of the function, you don't need to reference it specifically. Doing so just eliminates ambiguity for more complicated function calls. You will come across a lot of examples of code that do NOT reference the arguments by name.

``` R
readr::read_csv("https://github.com/tidyverse/readr/raw/main/inst/extdata/mtcars.csv")
```

By default, `readr::read_csv()` tries to guess whether column/variable names are present. If you know they exist, you can set `col_names = TRUE`.

``` R
readr::read_csv("https://github.com/tidyverse/readr/raw/main/inst/extdata/mtcars.csv", col_names = T)
```

If the names are present and you set `col_names = FALSE`, you will get a mess because `readr` will assume the header row is data just as the rest of the file.

``` R
readr::read_csv("https://github.com/tidyverse/readr/raw/main/inst/extdata/mtcars.csv", col_names = F)
```

As you can see, the column names are all prefixed with "X" and the first row is now the name of the headers. `names()` or `colnames()` will return the column names, so we can apply it and see what happens. We will wrap `readr::read_csv()` in `names()`. See how this is a problem. You can use `colnames()` to test this too.

``` R
names(
  readr::read_csv("https://github.com/tidyverse/readr/raw/main/inst/extdata/mtcars.csv", col_names = T)
  )
```

## **Reading a `.csv` File Stored Locally on your Computer**

If a file actually existed on your computer, the file would not be a URL but rather the path location to where the file is stored locally. In order to demonstrate this, we will assume there are no data files on your computer and will write one there so that you can access it. Let's assign it to an object and save it.  

``` R
DF <- readr::read_csv(
  file = "https://github.com/tidyverse/readr/raw/main/inst/extdata/mtcars.csv", 
  col_names = T)
```

Now that the data frame is saved as an object, let's write it out using `readr:: write_csv()`. We will specify the object to write, `x` , and the  `file` which actually includes the file path + file name. If your file is large and you wanted to compress it on save, use `readr::write_rds()`. The `here::here()` function simplifies combining the file path and file name especially when dealing with sub-directories because it assumes the base path is the project directory. It then combines all the strings you pass as arguments to formatted everything as path. In other words, you don't have to worry about pasting strings together using `paste()`. 

``` R
here::here()
```

```{r}
here::here()
```


Let's see how it works by passing two strings, `"data"` and `"mydatafile.csv"`. Passing `"data"` alone will provide the path to the data sub-directory and combining the file name will provide the path to that file in the data directory.


``` R
here::here("data")

here::here("data", "mydatafile.csv")
```

```{r}
here::here("data")

here::here("data", "mydatafile.csv")
```


To write the file, specify the data frame to save, `x`, and pass the path to `file`.

``` R
readr::write_csv(
  x = DF, 
  file = here::here("data", "mydatafile.csv")
  )
```

Of course, you don't need to assign it to an object in order to save it. You could assign `read_csv()` to `file` and the returned data frame will be the object to save. This approach does everything in one step but can be a little cumbersome for some people. Pick your poison.  

``` R
readr::write_csv(
  x = readr::read_csv(
        file = "https://github.com/tidyverse/readr/raw/main/inst/extdata/mtcars.csv", 
        col_names = T)
  file = here::here("data", "mydatafile.csv")
  )
```

After a successful write, the data frame will be saved as a file on your local system. You can read it from that location using the same path designated with `here::here()`.

``` R
readr::read_csv(here::here("data", "mydatafile.csv"))
```


## **Reading Raw Data Files that are Comma-Separated**

If you are not aware, data files can take many forms depending on how they are saved. Sometimes value content on rows are separated by commas, other times tabs, and other times even special characters or spaces. When they are commas-separated-values files, they are known as `csv` files, tab-separated as `tsv`, and so on. Other files will be Microsoft Excel formatted files (e.g., `xls`, or `xlsx`), SPSS data files (e.g., `sav`), and still others. To open special files, the [haven](https://haven.tidyverse.org/) library can serve you well. 

And if you have large files or simply want to read files in a blink of the eye, check out [`vroom`](https://vroom.r-lib.org/). `Vroom` can read files over 25 times faster than `readr` can especially when dealing with lots of character type data files.


Nevertheless, use `readr::read_csv()` to read [baby-names-2008.csv](https://raw.githubusercontent.com/slicesofdata/dataviz23/main/data/baby-names-2008.csv) from a remote website.

``` R
#readr::read_csv("https://raw.githubusercontent.com/slicesofdata/dataviz23/main/data/baby-names-2008.csv")
```


If there were only data in the file and no names, the file might look like that below. We can imitate this by skipping the first row (containing names) using `skip =`.

``` R
readr::read_csv("https://raw.githubusercontent.com/slicesofdata/dataviz23/main/data/baby-names-2008.csv", skip = 1)
```

Notice how the first row is assumed to be the names. Setting `col_names = F` will fix the problem. Putting the arguments on separate rows of `R` code might improve code legibility.

``` R
readr::read_csv("https://raw.githubusercontent.com/slicesofdata/dataviz23/main/data/baby-names-2008.csv", 
                skip = 1,
                col_names = F)
```


But we have no column names now. Setting `col_names =` some names will fix that. Use `c()` to combine 4 names, e.g., `col_names = c("name1", "name2", "name3", "name4")`.

``` R 
readr::read_csv("https://raw.githubusercontent.com/slicesofdata/dataviz23/main/data/baby-names-2008.csv", 
                skip = 1,
                col_names = c("year", "name", "percent", "sex"))
```


## **Reading Data from a Library/Package**

As mentioned earlier, `mtcars` is a data set on cars which is also part of `R`, meaning you do not need to read it from anyplace. `R` does this automatically. Because the file is long, we will get the head of the data frame using `head()` and then `print()` that subset. 

```{r}
print(head(mtcars))

# or 
head(mtcars)
```

And the column names...

```{r}
names(mtcars)
```


# **Assigning a Data Frame to an Object**

Unfortunately, once you read data into `R` what you see is only the returned content from the functions. This approach will not allow you to perform other operations on the data frame itself very easily because you would have to read the file over and over every time you wished to perform a different operation. The solution could involve assigning the data to an object. 



## **Assign the Data to an Object**

You'll want to take the data frame object that is returned by the `read.csv()` function and assign it to an object of a given name. Although the concept of assignment will be covered later, for now just understand that we need to make the data more accessible to work with. You could name the object anything you want. Let's assign it to `BABIES` standing for `data frame` and let's make it ALL CAPS. You can name it something else and use different casing but to make data frames distinctly recognizable from other objects like functions, plots, etc., I usually use all caps. Appending `_dat` would also be another convention.  

## **Using base `R`'s built-in `read.csv()` and `read.table()`**:

```{r}
BABIES <- read.csv("https://raw.githubusercontent.com/slicesofdata/dataviz23/main/data/baby-names-2008.csv")

# or 
BABIES <- read.table("https://raw.githubusercontent.com/slicesofdata/dataviz23/main/data/baby-names-2008.csv", 
                     sep = ",")

```


## **Using `read_csv()` from `readr`**:

```{r}
BABIES2 <- readr::read_csv("https://raw.githubusercontent.com/slicesofdata/dataviz23/main/data/baby-names-2008.csv") 

print(BABIES2)
```

## **Data as a Data Frame**

You should be an object named `BABIES` that contains the data frame with baby names. If you want to see that it actually is a data frame object, you can pass the `BABIES` object into the `is.data.frame()` function. If this is a data frame, the function will return `TRUE` and `FALSE` if it is not.

``` r
is.data.frame(BABIES)


is.data.frame(BABIES2)  # tibbles are also data frames
```

```{r}
is.data.frame(BABIES)


is.data.frame(BABIES2)  # tibbles are also data frames
```


## **Are they both `tibbles`?**

``` r
tibble::is_tibble(BABIES)


tibble::is_tibble(BABIES2)
```

```{r}
tibble::is_tibble(BABIES)


tibble::is_tibble(BABIES2)
```

Now the you have the data frame, you can examine some of its contents, for example, the first 6 rows using the `head()` function.

```{r}
head(BABIES)    # hmm, something seems off.
```

Because header rows at the top of the `.csv` file, specify that they exist by passing `TRUE` to the `header` argument of the function (e.g., `header = TRUE` or `header = T`).

```{r}
BABIES <- read.table("https://raw.githubusercontent.com/slicesofdata/dataviz23/main/data/baby-names-2008.csv", 
                     sep = ",", 
                     header = TRUE)
```

And view the head.s

```{r}
head(BABIES)    # Perfect!
```

# **Writing/Exporting Data Files**

Data frames can be written or saved as `.csv` files using `readr::write_csv()`, as r data files using `readr::write_rds()`, as Excel `.csv` files using `readr::write_excel_csv()`, as well as other formats.

If you query `R` using `?readr::write_excel_csv()` or `write_excel_csv()` having already loaded `readr` using `library(readr)`, you will see the arguments

``` R
?readr::write_csv
```

OK, let's just load the library using `library()`.

```{r}
library(readr)
```

When writing a file using `write_csv()` we need to specify the data object and a file name. 

```{r message=FALSE, warning=FALSE}
write_csv(x = mtcars,
          file = here::here("data", "my_mtcars.csv")
)
```


# **Looking at the `head()` and `tail()` of a Data Frame**

To see the head of the data frame, we can use the `head()` function. Let's wrap the `read.csv()` function in the `head()` function. Also, notice the `header` names at the top.

```{r}
head(BABIES)

head(mtcars)
```

And the tail...

```{r}
tail(BABIES)
```

A tail of length 8...

```{r}
tail(mtcars, n = 8)   # 8 rows
```

# **Reading Large Files Using `fread()` from `data.table`**

Now, sometimes you might work with very large files over 1 GB in size. If so, `read.csv()` and `read.table()` from base `R` will be extremely slow. You'll want a function from another library. You can check out [`vroom::vroom()`](https://vroom.r-lib.org/) or  [`data.table::fread()`](https://vroom.r-lib.org/). Install libraries as necessary.
