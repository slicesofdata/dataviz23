---
title: "**Data subsets and summaries**"
author: "Gabriel I. Cook"
#date: "`r Sys.Date()`"
date: "`r format(Sys.time(), '%d %B, %Y')`"

# this is a test to fingure out why there is the following error when rendering many quarto files:
# ERROR: The filename, directory name, or volume label syntax is incorrect. (os error 123)
---

::: callout-important
## Under construction. 

This page is a work in progress and may contain areas that need more detail or that required syntactical, grammatical, and typographical changes. If you find some part requiring some editing, please let me know so I can fix it for you.

:::

```{r}
#| label: load-packages
#| include: false

#library()
#library()
```

# **Overview**

This module demonstrates how to use **{dplyr}** to subset data, mutate variables, and summarize variables in data frames. Many data summaries involve creating group-level statistics so we will also cover grouping across variables. **{lubridate}** will be used to handle time vectors.


# **To Do**

## **Readings**

- TBA 


## **Task**

- TBA

## **Libraries** 

- **{here}**: `r packageVersion("here")`: for path management
- **{dplyr}** `r packageVersion("dplyr")`: for selecting, filtering, and mutating
- **{magrittr}** `r packageVersion("magrittr")`: for code clarity and piping data frame objects
- **{lubridate}** `r packageVersion("lubridate")`: for handling date and time vectors


## **External Functions**

Provided in class:

`view_html()`: for viewing data frames in html format, from `/r/my_functions.R` 

You can use this in your own workspace but I am having a challenge rendering this of the website, so I'll default to `print()` on occasion.

```{r}
source(here::here("r", "my_functions.R"))
```

## **Libraries**

We will work with a few different libraries for data manipulation. Let's load them into our work space using `library()`.

```{r}
library(magrittr)
library(dplyr)
library(stringr)
library(lubridate)
```


# **Loading and Looking at Data**

In order to perform any data summary, you need data. We will use the file name `"cms-top-all-time-2023-swim.csv"` and **{here}** to help with the path that we will pass that to `readr::read_csv()`. When we will assign the returned data frame to an object named `DAT`.

```{r}
file_name <- "cms-top-all-time-2023-swim.csv"

DAT <- readr::read_csv(
  here::here("data", file_name)
  )
```

View its contents:

```{r}
print(DAT) #view_html(DAT)
```

We have several variables: `r names(DAT)`. Some appear to be numeric and some are characters. Passing the data frame to `dplyr::glimpse()` will provide more detail (see also `str()`). 

```{r}
dplyr::glimpse(DAT)
```

Hmm, looks like there are `<chr>` and `<dbl>` variables and some numbers are in quotes. Objects in quotes are strings. So we need to clean up the file before we can even get a summary.


```{r}
is.numeric(DAT$time)
```

OK, so this variable is definitely not numeric. Looking at the file, we need to convert at least one variable that should be numbers from character to numeric. 


# **Modifying a Data Frame or Tibble Using {dplyr}**

Use `dplyr::mutate()` to create, modify, and delete column variables. At every least, you will need to pass a data frame as the first argument, `.data` and then a name-value pair as the second argument. There are other arguments that are experimental which will not be the focus of this module. 

```
mutate(
  .data,
  ...,
  .by = NULL,
  .keep = c("all", "used", "unused", "none"),
  .before = NULL,
  .after = NULL
)
```

We will use `mutate()` in conjunction with **{magrittr}**'s `%>%` for code piping.


## **Creating a new variable**

We will pass the data frame into `mutate()` and then specify a name-value variable pair. When using `%>%`, the data frame piped into the function will be represented as `.`. This `.` is not needed but serves as a good reminder that the data frame that is passed is the one from the previous line of code. In order to keep the print out manageable, we will also use the `slice()` function.


```
mutate(data frame, new variable name = variable) %>%
```

Create new variables that are set to a constant number or string:

```{r}
DAT %>%
  slice(., 1:5) %>%   # rows 1 through 5
  mutate(., newvar1 = 9999) %>%
  mutate(., newvar2 = "Student") 
```

You can see that each row in the data frame will take on the paired value. 


## **Modifying a new variable**

New variables are modified using the same name-value pairing approach. When you modify a variable, you are taking an existing variable to setting it to another value. 

### *Set an existing variable equal to a constant*

Just use an existing variable name (left of `=` in name-value pair).

```{r}
DAT %>%
  slice(., 1:5) %>%   # rows 1 through 5
  mutate(., time = 1) %>%
  mutate(., name = "0") 
```

OK, that's not very helpful. We just replaced our existing variables with nothing useful. You can see that name is still a `<chr>` type.


### *Set an existing variable equal to another value*

As long as **{dplyr}** can result the character elements of the vector, `as.numeric()` will convert the character strings to numbers. For example: 

```{r}
as.numeric(c("1", "3.2", "6.99"))
```

We can illustrate in a data frame by creating character value that will serve as the constant, and use `as.numeric()` just to illustrate this example.

```{r}
DAT %>%
  slice(., 1:5) %>%   # rows 1 through 5
  mutate(., name = as.numeric("0")) 
```

And now `name` is a `<dbl>`, which is a type of numeric. We can see this by selecting columns from the data frame `where()` the variable `is.numeric()`.

```{r}
DAT %>%
  slice(., 1:5) %>%   # rows 1 through 5
  mutate(., name = as.numeric("0")) %>%
  select(., where(~is.numeric(.)))
```

But if we try to convert `time` to numeric this way, you will see that the complex numbers will be converted to `NA`s, or missing.

```{r}
as.numeric(DAT$time)
```

The problem we have is that the data are not in a clean form. In this data frame, some elements of `time` are composed of numbers, decimals, and colons (e.g., x.xx, xx:xx.xx, etc.). which all make up elements that would be numbers. 


### **Converting variables that are time related using {lubridate}**

**{lubridate}** is a library for dealing with dates and times. It is also part of the **tidyverse}** ecosystem. 

The `period_to_seconds()` function will convert periods to seconds depending on the period format. We need to pass to it an objec that equates to a period of seconds.

For `time`, the format is: hour minute second (e.g., `hms`). And there is a `hms()` function to handle this. Let's see how it works before modifying the data frame. Load the library if it is not loaded. 

We will pass a single character string and convert it to `hms` with `hms()` and then convert that to seconds using `period_to_seconds()`. Because 60 minutes and 1 hour is the same number of seconds, we should end up with the same values. We can also use `ms()` to convert the format into minutes and seconds and pass to `period_to_seconds()`. Following the examples, we will apply to the vector in the data frame.

```
lubridate::period_to_seconds(lubridate::ms())
lubridate::period_to_seconds(lubridate::hms())
```

Sixty minutes and one hour to `hms`:

```{r}
lubridate::hms("00:60:00")
lubridate::hms("01:00:00")
```

One day to `hms`:

```{r}
hms("24:00:00")
```


Sixty minutes and one hour to `hms` to seconds:

```{r}
lubridate::period_to_seconds(lubridate::hms("00:60:00"))
lubridate::period_to_seconds(lubridate::hms("01:00:00"))
```

OK, good. So let's see if we can convert `time`. Because `hms()` is passed into `period_to_seconds()`, we first need to verify that `hms()` can handle it.

```{r}
hms(DAT$time)
```

Yikes! Note the warning and look at the output. Some strings failed and turned to `NA`. Looking and the `time` vector again, we see that contains both values like `1:52.83` and `23.87`. If there is only one `:`, we should be able to use `ms()`. 

```{r}
ms(DAT$time)
```

Great! All elements are in the form of `"xxM XXs"`. But does **{lubridate}** also convert seconds to a numeric value when using `period_to_seconds()`? If loaded, we can also remove the name of the library when calling the functions.

```{r}
is.numeric(period_to_seconds(ms(DAT$time)))
```

So let's go ahead and modify the character vector named `time` to a numeric vector representing seconds. 

```{r}
period_to_seconds(ms(DAT$time))
```

Perfect! Let's `mutate()` that variable in the data frame.

```{r}
DAT %>%
  slice(., 1:5) %>%   # rows 1 through 5
  mutate(., time = period_to_seconds(ms(time)))  
```

Let's look at `DAT` now and see those seconds.

```{r}
DAT
```

The data frame has not changed. The final step is to assign assign the returned data frame to an object. Remove the `slice()` so we get the entire data frame.

```{r}
DAT <- DAT %>%
  mutate(., time = period_to_seconds(ms(time)))  
```


Now let's write this to `/data`. But we don't want to overwrite this file. **{here}** won't be as effective but we can concatenate the `file_name` string object with a prefix like `"cleaned"` using the `paste()` function in `base R`. We will add a hyphen, `-`, by passing it to the `sep` argument. 

```{r}
paste("cleaned", file_name, sep = "-")
```

When paired with `here::here()`, does the full file path look right?

```{r}
here::here("data", paste("cleaned", file_name, sep = "-"))
```

Got our new file name! Let's write!

```{r}
readr::write_csv(DAT, here::here("data", paste("cleaned", file_name, sep = "-")))
```

Done!

# **Quick Summary Using `base R`**

If you want a quick summary of data, `summary()` will provide some basic information for you. You can pass a data frame to the function.

```{r}
summary(DAT)
```


# **Summarizing Data Using {dplyr}**

However, there are many ways to summarize data. To introduce data summary techniques using **{dplyr}**, we will open `DAT` and use `dplyr::summarise()` or `dplyr::summarize()` to summarize the data. The `summarise()` function works similar to `mutate()` insofar as it creates variables but it differs insofar as the data frame returned from `summarise()` contains only the variable(s) referenced in as part of that summary process. This includes some function calls immediately prior to `summarize()`. 

In the example below, we summarize by creating a new variable which is set to represent some data summary technique. In essence, summarizing is for descriptive statistics. Using `mean()`, we can summarize the data by taking the mean of the `time` variable.

```
summarize(.data, 
   ..., 
   .by = NULL, 
   .groups = NULL
   )
```

```{r}
DAT %>%
  summarise(., 
            mean = mean(time, na.rm = T),
            )
```


Notice what is returned is a single value reflecting the mean of all the data in the data frame. We could have obtained the same without using **{dplyr}**.

```{r}
mean(DAT$time, na.rm = T)        # $ notation
```

But we lose flexibility of easily adding new summary procedures. We can summarize by two name-value pair functions.

```{r}
DAT %>%
  summarise(., 
            mean = mean(time, na.rm = T),
            sd   = sd(time, na.rm = T)
            )
```

Now there is a mean and standard deviation for price. You can also add the sample size using `dplyr::n()`. 

```{r}
DAT %>%
  summarise(., 
            mean = mean(time, na.rm = T),
            sd   = sd(time, na.rm = T),
            n    = n()
            )
```


# **Summarizing `across()` Multiple Variables**

Summarizing a single variable is useful but if you want to summarize by many, you likely do not want to code a new line for each variable. In such cases, you can use `across()` as a helper function as was used for creating new variables with `mutate()` (see previous lesson).  

`across()` has three main arguments:

- `.cols`: specifies the columns to summarize across
- `.fns`: specifies the function(s) for the summary
- `.names`: specifies the output variable names 

Remember `across()` will want you to pass the columns to summarize by, `.cols`, the function for how to summarize, `.fns`, and the names for how to name the new variables, `.names` (which will be `NULL` by default). The `.x` here stands for passing the vector to the mean function and not the data frame. More on `~` and `.x` later.

## *Summarize across by numeric variables:*

```{r}
DAT %>%
  summarise(., across(.cols = where(is.numeric), 
                      .fns  = ~mean(.x, na.rm = TRUE))
            )
```

Well, that's now actually impressive because there is only one numeric variable. What if we had more that were piped to `summarize()`?

```{r}
DAT %>%
  mutate(., 
         num1 = time,
         num2 = time,
         num3 = time
         ) %>%
  summarise(., across(.cols = where(is.numeric), 
                      .fns  = ~mean(.x, na.rm = TRUE))
            )
```

That was easy.


Because `across()` is so powerful, let's just add another variable to the data frame for using in examples. You might also wish to reorder the position of variables in the data frame so that they are grouped in some way. We can use `dplyr::relocate()` to accomplish this. We will move the `time` column to the position `.before` one of the new variables using `relocate(., time, .before = min)`.

Doing so will also show you some ways to create variables. 

```{r}
DAT <- DAT %>%
  mutate(., 
         sec = time,  # will be redunant with time but named accurately
         min  = time/60,
         hour = time/(60*60)
         ) %>%
  relocate(., time, .before = sec)
```

Take a look:

```{r}
head(DAT)
```


Variable names created with `across()` is controlled using the `.names` argument. The default is equivalent to `.names = {.col}`, which means that the name(s) are inherited from the `.cols` argument; the names are a stand-in for the name specification. If you wish to have control over the names, you can pass a string that that either appends  (e.g.,`"{.col}suffix"`) or prepends (e.g.,`"prefix{.col}"`) a string to each column name. 
This string looks odd because it's a special *glue* specification that glues together with a string with an object. We will use this concept later when using the **{glue}** library. 

When modifying `.names`, include a character like `"_"` (e.g.,`"{.col}_suffix"`) so that the column names and the appended text are separated, making the name easily legible. If you summarize to create means, a good suggestion is something like (e.g.,`"{.col}_mean"` or (e.g.,`"{.col}_mn"`)) so that you know the variable is a mean. If you prefer the function name first, you can use a prefix (e.g.,`"mean_{.col}"`).


```{r}
DAT %>%
  summarise(., across(.cols = c("sec", "min", "hour"), 
                      .fns  = ~mean(.x, na.rm = TRUE),
                      .names = "{.col}_mean"
                      )
            )

```

You can see how all variables in the summary end in `"_mean"`.


You can also glue the function and the column names together by passing `.names = "{.col}_{.fn}"`. 

```{r}
DAT %>%
  summarise(., across(.cols = c("sec", "min", "hour"), 
                      .fns  = ~mean(.x, na.rm = TRUE),
                      .names = "{.col}_{.fn}"
                      )
            )


```

You you will see there is a number that is appended to the variable name. This is because there is only one function passed to `.fns`. You can pass more using a special object called a list (see `?list`). Unlike vectors, elements of lists need not be the same kind. Elements of lists can combinations of characters, numbers, data frames, functions, etc.


## *Passing multiple functions in a `list()`*

Passing functions as a list requires a little fancy coding. We will pass two functions as a `list` so that we can calculate both the `mean()` and the `sd()` on the variables passed to `across()`.  

A `list` is a special object (e.g., container) for which its elements can be different types of objects. Whereas elements of `vectors` can be only character or only numeric, elements of lists can hold different object. One element can be a numeric vector, another element a data frame, another element a character vector, etc. Many functions used in R will actually return lists for which elements contain different types of objects.

OK back to two or more functions. If you pass a `list()` with arguments for the `mean` and the `sd` (e.g., `list(mean, sd)`, you can summarize by both. If you want to prevent errors (yes you do) and want to keep the summaries separate (probably so), you can modify `.names` to pass both the column and the function (e.g., `"{.col}_{.fn}"`). The underscore is not needed here; it only helps with readability of the variables so that you don't end up with variable names like `var1mean` but instead `var1_mean`.

Let's pass the summary procedures as a `list` to include measures of mean and standard deviation for the variables.

```{r}
DAT %>%
  summarise(., across(.cols  = c("sec", "min", "hour"), 
                      .fns   = list(mean, sd),
                      .names = "{.col}_{.fn}")
            )
```

Well those are not exactly the names we want but it illustrates how names are created. Because we have two summary functions for each column variable passed to `across()`, they are enumerated according to the order in the list (e.g., mean then standard deviation).

### Fixing `.names` when passing lists to `.cols`  

Enumeration isn't helpful with remembering variables. There are different ways to do fix this problme, some of which may be better under certain scenarios. You have to determine what approach is best but I'll lay out some limitations. If you pass only the functions into the list, then when you pass `{.fn}` to `.names`, the variable names in the returned data frame will take on a numeric value representing the order/element position of the functions as you entered them in the `list`. In this coding instance, means would be named with`"_1"` and standard deviation names with `"_2"`. This approach, however, leads to confusing variable names because you have to remember which is 1 and which is 2 and of course explain this to anyone with whom you share the data. Let's take a look. 


A better approach could be to assign the `mean` and `sd` functions names in the `list()` function call so that the name is appended and the variable is named meaningfully. Let's modify what we pass to `.fns`.

```{r}
DAT %>%
  summarise(., across(.cols = c("sec", "min", "hour"), 
                      .fns  = list(mean = mean, 
                                   sd = sd,
                                   n = length
                                   ),
                      .names = "{.col}_{.fn}")
            )
```

Importantly, however, certain functions like `mean()` will operate in ways you might not expect. One one hand, it does what we expect when all elements can be used to calculate the mean. 

```{r}
mean(DAT$time)
```

But if there is a missing value, it does something else. Let's add an `NA` to the vector.

```{r}
mean(c(DAT$time, NA))
```

The function returns `NA`. If there is just one `NA`, `mean()` returns `NA`. By design this is actually good. 

The standard deviation of a vector, `sd()`:

```{r}
sd(c(DAT$time, NA))
```

The median of a vector, `median()`:

```{r}
median(c(DAT$time, NA))
```

The length of a vector, `length()`:

```{r}
length(c(DAT$time, NA))
```

Well, that's interesting. By default `length()` will return the number of elements of the vector including `NA`s but by default `mean()` will not return the mean of a vector with `NA`s because `na.rm = FALSE` by default. If you wish to calculate the mean by removing the `NA`s, pass `na.rm = TRUE`. 

```{r}
mean(c(DAT$time, NA), na.rm = T)
```

Make note, however, that the length of this vector is shorter than the length with `NA`s. We can test this on a vector with and without the `NA` by using `na.omit()` to omit any of them. Using our vector we added an `NA`, let's omit it.

```{r}
na.omit(c(DAT$time, NA))
```

And its length:

```{r}
length(na.omit(c(DAT$time, NA)))
```

This behavior is important because if you want to obtain the mean of a variable with `NA`s and the sample size using `length()`, your sample size will be inaccurate.


In order to see these operations on a data frame and in the context of `dplyr::summarize()`, let's modify the data frame to include an additional row with some mission values. One simple approach is to use `base R` to use `rbind()` to bind a new row to the end of the data frame. In this case, the contents of that new row will be the same as the first row of the data frame (e.g., `DAT[1,]`). Then the name will be changed and some values will be made missing.

```{r}
DAT <- rbind(DAT, 
             DAT[1,]
             )
```


```{r}
DAT[dim(DAT)[1], ]                              # the current row contents
DAT[dim(DAT)[1], "name"] <- "Anonymous"         # make name anonymous
DAT[dim(DAT)[1], c("sec", "min")] <- c(NA, NA)  # set these cells to NA
```

Are `NA`s across the last row now?

```{r}
DAT %>% tail()
```



Approach #2:

When functions do not contain argument for dealing with `NA`s, there is `na.omit()`, a function that takes an object and removes `NA`s. So you can just pass the variable to `na.omit()` and then wrap it in the metric function of interest. Also, because `na.rm = T` cannot be used for `length()`, `na.omit()` offers consistency across all functions and as a result, I believe, less confusion.

Unfortunately, accomplishing this task can be rather tricky and requires some new syntax. This requires usage of what's called a "lambda" technique. Using this type of syntax, we can pass functions to the `.fns` argument. The `?across()` documentation calls it "a **{purrr}**-style lambda" in the arguments section. This approach can be a little bit confusing, so I’m going to show you an example, and then walk through it step by step.

We need to precede the function with `~` and reference the vector using `.x`. Let's do this and change the `.fns` argument slightly.

General Example:

`name = ~function(na.omit(.x))`


We will summarize only `time` and `sec` because those variables are identical except for the row we added. We will also add `dplyr::n()` to see what's going on with that function. 

```{r}
DAT %>%
  summarise(., across(.cols = c("time", "sec"), 
                      .fns  = list(mean = ~mean(na.omit(.x)),
                                   #sd = ~sd(na.omit(.x)),
                                   len = ~length(na.omit(.x)),
                                   n = ~dplyr::n()
                                   ),
                      .names = "{.col}_{.fn}"
                      )
            ) 
```

So what happened? The means and lengths for `time` and `sec` are not the same. Means differ because they are calculated by different values depending on the presence of `NA`s. But notice that the n's are the same based on `dplyr::n()`. How can the means and differ if the n's are the same?  

So what's the point of all of this? Well, you need to be careful not to apply functions and assume they are doing what you believe you are doing. You always need to be smarter than the code you use. Also, there is no single answer for dealing with data. Sometimes one approach will be appropriate and in other instances another approach will be. You as the data scientist need to know that there are different methods so that you an decide where to apply those different methods. 



## **Summarize by Groups Using `group_by()`**


When you have subgroups in your data, you want to create summary statistics by group. A typical grouping approach is by some categorical or factor variable in a data frame. 

```{r}
glimpse(DAT)
```

```{r}
DAT %>%
  group_by(., ) %>%
  summarise(., across(.cols = c("time", "sec"), 
                      .fns  = list(mean = ~mean(na.omit(.x)),
                                   len = ~length(na.omit(.x)),
                                   ),
                      .names = "{.col}_{.fn}"
                      )
            ) 

```










We can write our own function that will handle the removal of `NA` the same way as `mean()` does. We just need to ensure we use `na.rm` and not something like `remove.na`. Let's name the function `length_na`.

```{r}
length_na <- function(x, na.rm = FALSE) {
  # as length() substitute that calculates length with and without NAs
  if (na.rm) {
    x = length(na.omit(x))
  } else {
    x = length(x)
  }
  return(x)
}
```




```{r}
DAT %>%
  summarise(., across(.cols = c("sec", "min", "hour"), 
                      .fns  = list(mean = mean, 
                                   sd = sd,
                                   n = length_na, 
                                   ),
                      .names = "{.col}_{.fn}",
                      \(.x), na.rm = TRUE
                      )
            )
```








mean(c(DAT$time, NA), na.rm = T)


Importantly, however, if a vector contains even one `NA`, remember the returned statistic for the entire vector will also be `NA`. The previous code will *NOT* return correct statistics if you have an `NA`.

You will want to remove them either by filtering rows for `complete.cases()` or omitting `NA`s from the summary statistic function. To illustrate, let's make some data missing in the data frame. Because there are 53,940 rows in the data frame, we can simply make some data in the last row missing. Let's change the data in `depth` and `table` variables to `NA` just to illustrate the point.

```{r}
diamonds[53940, c("depth", "table")]   # the current data

diamonds[53940, c("depth", "table")] <- NA # set these cells to NA

tail(diamonds)               # see missing values
```

Now filter out missing cases...

```{r}
diamonds %>%
  filter(., complete.cases(.)) %>%
  group_by(., cut) %>%
  summarise(., across(.cols = c("carat", "depth", "table"), 
                      .fns  = list(mean = mean, 
                                   sd = sd,
                                   n = length),
                      .names = "{.col}_{.fn}"
            ))
```



if a vector contains even one `NA`, remember the returned statistic for the entire vector will also be `NA`. The previous code will *NOT* return correct statistics if you have an `NA`.

You will want to remove them either by filtering rows for `complete.cases()` or omitting `NA`s from the summary statistic function. To illustrate, let's make some data missing in the data frame. Because there are 53,940 rows in the data frame, we can simply make some data in the last row missing. Let's change the data in `depth` and `table` variables to `NA` just to illustrate the point.

```{r}
diamonds[53940, c("depth", "table")]   # the current data

diamonds[53940, c("depth", "table")] <- NA # set these cells to NA

tail(diamonds)               # see missing values
```

Now filter out missing cases...

```{r}
DAT %>%
  filter(., complete.cases(.)) %>%
  summarise(., across(.cols = c("sec", "min", "hour"), 
                      .fns  = list(mean = mean, 
                                   sd = sd,
                                   n = length),
                      .names = "{.col}_{.fn}"
            ))
```





Let's pass the summary procedures as a `list` to include measures of mean, standard deviation, and the sample size (number of observations) contributing to the mean and standard deviation. Unfortunately, `dplyr::n()` will throw an error when placed in the list. 


As you know,`length()` will also return the length of the vector but in this case as part of the the grouping variable because `group_by()` precedes the summary.






## *Summarize across by variable name vector:*

```{r}
DAT %>%
  summarise(., across(.cols = c("time", "num1"), 
                      .fns  = ~mean(.x, na.rm = TRUE),
                      .names = "{.col}_mean")
            )
```










# **Summarizing Data Using `group_by()`**

A summary of the entire data set is fine for understanding grand mean and other metrics but this lacks information at a group level, for example, by sex, ethnicity, personality, city, job title, or in the `diamonds` data by diamond `cut`, `clarity`, or other variation.

When summarizing data, you will often want to summarize by levels of other variables, either categorical or numeric. In such cases, you can `group_by()` another variable and then summarize.

Let's summarize in several ways after grouping by diamond `cut`.

```{r}
DAT %>%
  group_by(., event) %>%
  summarise(., 
            n = n(),  # or also length()
            mean = mean(time, na.rm = T),
            sd   = sd(time, na.rm = T)
            )
```



