---
title: "Operation Span"
#author: ""
#date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
# https://data.library.virginia.edu/using-and-interpreting-cronbachs-alpha/
rm(list = ls(all.names = TRUE))
knitr::opts_chunk$set(echo = TRUE)

source("https://pastebin.com/raw/8mXH02yg")   # run and comment out before knitting
source("https://pastebin.com/raw/97NNTTzu")   # run to include in function definitions

# set the paths for project, script, and data dirs
proj_dir <- gsub("GCDS.*.Rmd", "GCDS", get_ActivePath())
proj_name = ""
r_dir    <- paste(proj_dir, "r", sep = "/")    # r subdir
data_dir <- paste(proj_dir, "data", sep = "/") # data subdir
if ( proj_name != "" & !dir.exists(paste(proj_dir, proj_name, sep = "/")) ) {
  # create project dir
  suppressWarnings(dir.create(paste(proj_dir, proj_name, sep = "/")))
  r_dir <- gsub("/r", paste0("/", proj_name, "/r"), r_dir)
  data_dir <- gsub("/data", paste0("/", proj_name, "/data"), data_dir)
  # create sub directories
  suppressWarnings(dir.create(r_dir))
  suppressWarnings(dir.create(data_dir)) }
```

```{r}
# libraries and functions
library(dplyr)
library(caret)
library(magrittr)
library(dplyr)

# important functions
clean_cell <- function(x, 
                       brackets = T, 
                       quotes.sing = T,
                       quotes.doub = T,
                       commas = F
                       ) {
  # clean the messy cells
  if (brackets) x = gsub("[][]","", x)
  if (quotes.sing) x = gsub("'","", x)
  if (quotes.doub) x = gsub('"',"", x)
  if (commas) x = gsub(",","", x)
  return(x)
}

mean_of_string_split <- function(string, pattern = ",") {
  return(
    mean(as.numeric(unlist(
      stringr::str_split(string, pattern = pattern))))
  )
} 


# remove the comma
#a = "left,left,right"
#b = "left,right,left"
#a = c("left","left","right")
#b = c("left","right","left")
#(a == b)

mean_split_str <- function(string, pattern = ",") {
  return(
    mean(as.numeric(unlist(stringr::str_split(string, pattern))))
  )
}

sum_split_str <- function(string, pattern = ",") {
  return(
    sum(as.numeric(unlist(stringr::str_split(string, pattern))))
  )
}

matches_to_string <- function(stringList1, stringList2) {
  stringList1 = tolower(as.vector(unlist(
    stringr::str_split(stringList1, ","))))
  stringList2 = tolower(as.vector(unlist(
    stringr::str_split(stringList2, ","))))
  # convert the logical to string then to numeric
  m = paste(stringList1 == stringList2, collapse = ",")
  m = gsub("TRUE", "1", m)
  m = gsub("FALSE", "0", m)
  return(m)
} 

mean_matches <- function(stringList1, stringList2) {

  stringList1 = tolower(as.vector(unlist(
    stringr::str_split(stringList1, ","))))
  stringList2 = tolower(as.vector(unlist(
    stringr::str_split(stringList2, ","))))

  return(mean(stringList1 == stringList2))
} 

letterRec <- function(studyletters = "", recletters = "") {
  # compute the count for letters recalled independed of order
  counter = 0   # initialize counter
  
  if(recletters != "") { 

    # iterate through letters
    for (charPos in 1:nchar(studyletters)) { # for each studied 
      if(grepl(
        substr(studyletters, charPos, charPos), 
               x = recletters)) { # is the letter recalled
        counter = counter + 1                                             # increment counter
      } } } 
  return(counter)
}

# 
Recall_by_Position <- function(studyletters = "", recletters = "") {
  # compute the count for letters recalled in the correct position
  counter = 0   # initialize counter
  
  if(recletters != "") {
    for (charPos in 1:nchar(studyletters)) { # # iterate through letters, for each studied letter
      
      if(grepl(  # if the recalled letter is in the study position
        substr(studyletters, charPos, charPos), 
        substr(recletters, charPos, charPos))
        ) { 
        counter = counter + 1 # increment counter
        } }    }  
  return(counter)
} #lettersRecalledinOrder(studyletters = "", recletters = "")
```



Operation Span

Variables:

- `TotalErrors` = `SpeedErrors` +  `AccErrors`	

What are Speed and Acc errors?

- Spansum.total	
- Spnscr	
- Totaltrialcount

```{r}
#f = "C:/Users/gcook/Sync/Courses/GCDS/ospan4/data/77_OSpan4_2022-11-15_15h21.46.267.csv"

#C:\Users\gcook\Sync\Courses\GCDS\ospan4\data\gcds_ospan_21_01\data
SPAN <- pavlovia_Merge(
  dir_path = 'C:/Users/gcook/Sync/Courses/GCDS/ospan4/data', 
  pattern_select = '.csv')

# pattern_filter = '')

#view(SPAN)

#dat_file <- f %>%  read.csv(.)

###########################################################################
## Read file and select necessary vars
###########################################################################
#dat_file <- f %>%  read.csv(.) %>% #dat_file %>%
#  dplyr::select(., starts_with("task_")) %>% 
#  rename_with(., ~(gsub("task_", "", .x, fixed = T))) %>%
#  filter(., participant > 0) %>%
#  select(., -c(date, subid, exp, blockfile, 
#               operation, letter, operList, letter_end,
#               operation_resp, operation_rt))

SPAN <- SPAN %>%
  dplyr::select(., starts_with("task_")) %>% 
  rename_with(., ~(gsub("task_", "", .x, fixed = T))) %>%
  filter(., participant > 0) %>% 
  select(., -c(date, subid, exp, blockfile, 
               operation, letter, operList, letter_end,
               operation_resp, operation_rt))

#view(SPAN)

###########################################################################
## end
###########################################################################

SPAN %>% view()

SPAN_FULL <- SPAN

SPAN_PRAC <- ''

SPAN <- SPAN %>% 
  filter(., 
         phase == "real-task",
         SpanSize != "Ejemplo"
         )

SPAN %>% view(., filter = "none")

###########################################################################
## clean up the messy variables
###########################################################################
 
SPAN2 <- SPAN %>%
  mutate(., 
         letterList = tolower(letterList),
         letterList = clean_cell(letterList, T, T, T, T),
         
         # operation data
         operCorrList = clean_cell(operCorrList, T, T, T, F),
         operRespList = clean_cell(operRespList, T, T, T, F),
         operRtList = clean_cell(operRtList, T, T, T, F),
         
         corRec = clean_cell(corRec, T, T, T, T),

         letter_resp = clean_cell(letter_resp, T, T, T, T),
         # recode a "space" in the recall with 0  
         letter_resp = gsub("space", "0", letter_resp),

         letter_rt = gsub("[][]","", letter_rt),
         #letter_rt = gsub("[","", letter_rt)
  ) %>% 
  filter(., SpanSize %in% c("1", "2", "3", "4", "5", "6", "7")) %>%
  mutate(., SpanSize = as.numeric(SpanSize)) %>%
  mutate(., id = participant) %>%
  select(., c(id, SpanSize, letterList, corRec, letter_resp,
              letter_rt, starts_with("oper"))) %>%
  mutate(., rownumber = dplyr::row_number()) %>%
  arrange(., rownumber)

###########################################################################
## end
###########################################################################

SPAN2 %>% view(., filter = "none")

###########################################################################
## Cleaning up the RTs for the operation task 
###########################################################################

###########################################################################
## end
###########################################################################

###########################################################################
## Calculate trial level data and averages
###########################################################################
SPAN3 <- SPAN2 %>% 
  group_by(., id, rownumber) %>%
  mutate(.,
         # operation accuracy
         operAccList = matches_to_string(
           operCorrList, operRespList),
         # operation average
         operAccMean = mean_matches(operCorrList, operRespList),
         mean_oper_acc = mean_matches(operCorrList, operRespList),
         # operation acc
         oper_acc1 = as.numeric(
           stringr::str_split_fixed(operAccList, ",", n = 7)[1]),
         oper_acc2 = as.numeric(
           stringr::str_split_fixed(operAccList, ",", n = 7)[2]),
         oper_acc3 = as.numeric(
           stringr::str_split_fixed(operAccList, ",", n = 7)[3]),
         oper_acc4 = as.numeric(
           stringr::str_split_fixed(operAccList, ",", n = 7)[4]),
         oper_acc5 = as.numeric(
           stringr::str_split_fixed(operAccList, ",", n = 7)[5]),
         oper_acc6 = as.numeric(
           stringr::str_split_fixed(operAccList, ",", n = 7)[6]),
         oper_acc7 = as.numeric(
           stringr::str_split_fixed(operAccList, ",", n = 7)[7]),
         
         # operation rt
         # mean across all
         mean_oper_rt = mean_split_str(operRtList, ","),
         # sum across all
         sum_oper_rt  = sum_split_str(operRtList, ","),
         
         oper_rt1 = as.numeric(
           stringr::str_split_fixed(operRtList, ",", n = 7)[1]),
         oper_rt2 = as.numeric(
           stringr::str_split_fixed(operRtList, ",", n = 7)[2]),
         oper_rt3 = as.numeric(
           stringr::str_split_fixed(operRtList, ",", n = 7)[3]),
         oper_rt4 = as.numeric(
           stringr::str_split_fixed(operRtList, ",", n = 7)[4]),
         oper_rt5 = as.numeric(
           stringr::str_split_fixed(operRtList, ",", n = 7)[5]),
         oper_rt6 = as.numeric(
           stringr::str_split_fixed(operRtList, ",", n = 7)[6]),
         oper_rt7 = as.numeric(
           stringr::str_split_fixed(operRtList, ",", n = 7)[7]),
         
         # letter recall rt
         # mean across all
         mean_letter_rt = mean_split_str(letter_rt, ","),
         # sum across all
         sum_letter_rt  = sum_split_str(letter_rt, ","),
         letter_rt1 = as.numeric(
           stringr::str_split_fixed(letter_rt, ",", n = 7)[1]),
         letter_rt2 = as.numeric(
           stringr::str_split_fixed(letter_rt, ",", n = 7)[2]),
         letter_rt3 = as.numeric(
           stringr::str_split_fixed(letter_rt, ",", n = 7)[3]),
         letter_rt4 = as.numeric(
           stringr::str_split_fixed(letter_rt, ",", n = 7)[4]),
         letter_rt5 = as.numeric(
           stringr::str_split_fixed(letter_rt, ",", n = 7)[5]),
         letter_rt6 = as.numeric(
           stringr::str_split_fixed(letter_rt, ",", n = 7)[6]),
         letter_rt7 = as.numeric(
           stringr::str_split_fixed(letter_rt, ",", n = 7)[7]),
  ) %>% 
  select(., -c(letter_rt, operCorrList, operRespList, operRtList))
###########################################################################
## end
###########################################################################

SPAN3 %>% view(., filter = "none")

###########################################################################
## Calculate means across rows
###########################################################################
SPAN4 <- SPAN3 %>%
  #group_by(rownumber) %>%
  mutate(.,
    letterRecRt_mean = 
      mean(c_across(starts_with("letter_rt")), na.rm = T),
    
    #operAcc_mean = mean(c_across(starts_with("oper_acc")), na.rm = T),
    operRt_mean  = 
      mean(c_across(starts_with("oper_rt")), na.rm = T),
    ) 

SPAN4 %>% view(., filter = "none")
###########################################################################
## end
###########################################################################

###########################################################################
## Calculate letter recall for accuracy
###########################################################################
SPAN5 <- SPAN4 %>%
  group_by(., rownumber) %>%
  mutate(., 
         # (liberal scoring) calculate the # of letters recalled
         num_Rec = 
           letterRec(
             studyletters = letterList, recletters = letter_resp),
         # (strict scoring) calc the # of letters recalled in position
         num_Rec_by_Pos = 
           Recall_by_Position(studyletters = letterList, 
                              recletters = letter_resp),
         
         # proportionalize by span
         Recall_p = num_Rec/SpanSize,
         PosRecall_p = num_Rec_by_Pos/SpanSize
         )

SPAN5 %>% view(., filter = "none")

###########################################################################
## end
###########################################################################

SPAN5 %>%
  select(., c(SpanSize, letterList, letter_resp,
              num_Rec, num_Rec_by_Pos,
              Recall_p, PosRecall_p,
              mean_letter_rt, sum_letter_rt,
              operAccList, mean_oper_acc, 
              mean_oper_rt, sum_oper_rt)
         ) %>% view()

###########################################################################
## Summarize by id and SpanSize
###########################################################################

span_by_id <- SPAN5 %>% 
  group_by(., id, SpanSize) %>%
  summarise(., 
            Max_Span = sum(SpanSize),
            Rec_Sum  = sum(num_Rec, na.rm = T),
            Rec_Sum_by_Pos = sum(num_Rec_by_Pos, na.rm = T),
            
            Oper_Acc = mean(mean_oper_acc, na.rm = T),
            Oper_Rt  = mean(mean_oper_rt, na.rm = T),
            Oper_Rt_sum = mean(sum_oper_rt, na.rm = T)
            ) %>%
  mutate(., team = ifelse(as.numeric(id) < 9999, as.character(floor(as.numeric(id)/100)), "PSYC-40"))

span_by_id %>% view(., filter = "none")

span_by_id %>%
  select(., id, SpanSize, Rec_Sum_by_Pos) %>%
  filter(., id < 9999) %>%
  tidyr::pivot_wider(., 
    names_from  = SpanSize,
    values_from = Rec_Sum_by_Pos,
    names_prefix = "span_"
  ) %>% 
  #mutate(., across(.cols = starts_with("span"), as.integer)) %>%
  mutate(., 
         span_2 = span_2/10,
         span_3 = span_3/15,
         span_4 = span_4/20,
         span_5 = span_5/25,
         span_6 = span_6/30,
         ) %>%
  arrange(., desc(id)) %>%
  write.csv(., paste(data_dir, "ospan_wide.csv", sep = "/"), row.names = F)
  #mutate(., across(.cols = where(is.numeric), .fns = ~as.numeric(scale(.x)), .names = "{.col}_z")) #%>%
  #select(., -idz)
  #mutate(., _z = scale()) %>%
  # myabe this mutate(., across(.cols = where(is.numeric), scale, .names = "z_{.col}")))


###########################################################################
## Span Scores by Id
###########################################################################
span_scores <- span_by_id %>% 
  group_by(., id) %>%
  filter(., id < 9999) %>%
  summarise(., 
            #span_max    = sum(Max_Span),
            span_pos    = sum(Rec_Sum_by_Pos),
            span_no_pos = sum(Rec_Sum),
            
            oper_acc = mean(Oper_Acc),
            oper_rt  = mean(Oper_Rt),
            oper_sum = sum(Oper_Rt_sum)
            ) %>%
  mutate(., across(.cols = where(is.numeric), 
                   .fns = ~as.numeric(scale(.x)), 
                   .names = "{.col}_z")) %>%
  mutate(., across(where(is.numeric), round, digits = 3)) %>%
  select(., -id_z) %>%
  arrange(., desc(span_pos)) %>%
  mutate(., rank = row_number())
#mutate(., _z = scale()) %>%
# myabe this mutate(., across(.cols = where(is.numeric), scale, .names = "z_{.col}")))
#span_scores$span_z <- as.numeric(scale(span_scores$span_pos))

span_scores %>% view(., filter = "none")

################################################################################
## Adjust Span Score
################################################################################
span_scores_corrected <- span_scores %>%
  lm(span_pos ~ oper_acc, data = .)

span_scores$span_pos_adj <- span_scores_corrected$fitted.values

span_scores_corrected <- span_scores %>%
  lm(span_pos_z ~ oper_acc_z, data = .)

span_scores$span_pos_adj_z <- span_scores_corrected$fitted.values
#hist(span_scores_corrected$fitted.values)

summary(span_scores_corrected)
#lm.beta::lm.beta(span_scores_corrected)
parameters::parameters(span_scores_corrected)
performance::model_performance(span_scores_corrected)

span_scores <- span_scores %>% 
  arrange(., desc(span_pos_adj)) %>%
  mutate(., 
         rank_adj = row_number(),
         span_pos_adj = floor(span_pos_adj)
         ) %>%
  mutate(., across(where(is.numeric), round, digits = 2)) %>%
  relocate(., rank_adj, .after = rank) %>%
  arrange(., desc(span_pos_z)) %>%
  select(., id, span_pos_z, span_pos_adj, span_pos_adj_z, oper_acc, rank, rank_adj) %>%
  select(., id, span_pos_z, oper_acc, rank, rank_adj)
  
span_scores %>%
  select(., id, span_pos_z, oper_acc) %>%
  arrange(., span_pos_z) %>%
  write.csv(., paste(data_dir, "ospan.csv", sep = "/"), row.names = F)

span_scores %>%
  arrange(., desc(span_pos_z)) %>%
  view(., filter = "none")

span_scores %>%
  select(., starts_with("rank")) %>%
  cor(., method = "spearman")

################################################################################
################################################################################

span_by_id %>% view(., filter = "none")

span_by_id_wide <- ''

span_by_id %>%
  select(., -c(team, Max_Span, Rec_Sum, Oper_Acc, Oper_Rt, Oper_Rt_sum)) %>%
    tidyr::pivot_wider(., 
    names_from  = SpanSize,
    values_from = c(Rec_Sum_by_Pos, Rec_Sum, Oper_Acc, Oper_Rt, Oper_Rt_sum)
  ) %>%
  mutate(., across(.cols = where(is.numeric), 
                   .fns = ~as.numeric(scale(.x)), 
                   .names = "{.col}_z")) %>%
  mutate(., across(where(is.numeric), round, digits = 3)) #%>%
  
  group_by(., id) %>%


span_by_id_wide
span_by_id_wide %>% view(., filter = "none")



###########################################################################
## Span Scores Plot
###########################################################################

span_scores %>%
  select(., c(ends_with("_z"))) %>%
  GGally::ggpairs(.)

span_scores %>%
  select(., span_pos_z, span_pos_adj_z) %>%
  GGally::ggpairs(.) + see::theme_modern()

#reorder()
ggplot(span_scores, aes(span_pos_z)) +
  geom_histogram(color = "gray", fill = "yellow") + #binwidth = .1 
  xlab("Span Score (standardized)") + 
  #  scale_x_continuous(breaks = c(5, 15, 25)) + 
  see::theme_modern()

span_scores %>%
  #filter(., id > 9999) %>%
  ggplot(., 
       aes(x = reorder(id, span_pos_z),
           y = span_pos_z)
       ) +  
#           fill = variable)) + 
  geom_bar(stat = "identity", fill = "lightblue") + 
  scale_y_continuous(n.breaks = 20) +
  #coord_flip() + 
  see::theme_modern() + 
  theme(axis.text.x = element_text(
    angle = 90, hjust = 1)) + #
  xlab("id") + ylab("Span Score (standardized)")


#view(span_scores)

# accuracy
span_scores %>%
  #filter(., id > 9999) %>%
  ggplot(., 
       aes(x = reorder(id, oper_acc),
           y = oper_acc)
       ) +  
#           fill = variable)) + 
  geom_bar(stat = "identity", fill = "lightgreen") + 
  scale_y_continuous(n.breaks = 20) +
  #coord_flip() + 
  see::theme_modern() + 
  theme(axis.text.x = element_text(
    angle = 90, hjust = 1)) + #
  xlab("id") + ylab("Solve Accuracy")

# accuracy
span_scores %>%
  #filter(., id < 9999) %>%
  ggplot(., 
       aes(x = reorder(id, oper_rt),
           y = oper_rt)
       ) +  
#           fill = variable)) + 
  geom_bar(stat = "identity", fill = "midnightblue") + 
  scale_y_continuous(n.breaks = 20) +
  #coord_flip() + 
  see::theme_modern() + 
  theme(axis.text.x = element_text(
    angle = 90, hjust = 1)) + # Rotate axis labels
  xlab("id") + ylab("Average Solve Time (seconds)")


###########################################################################
## Span Scores and Stroop
###########################################################################
STROOP_wide <- readr::read_csv(paste(data_dir, "STROOP_agg.csv", sep = "/")) %>%
  select(., -c(odd, incongruent)) %>%
  group_by(., id) %>%
  tidyr::pivot_wider(., 
    names_from  = trialtype,
    values_from = c(rt, error)
  ) %>%
  mutate(., sie = rt_incongruent - rt_congruent)

#hist(STROOP_wide)
write.csv(STROOP_wide, paste(data_dir, "STROOP_agg_wide.csv", sep = "/"), row.names = F)
#%>% dplyr::summarise_all(purrr::discard, is.na) %>% distinct()

left_join(span_scores, STROOP_wide) %>% view(., filter = "none")

STROOP_SPAN <- 
left_join(span_scores, STROOP_wide) %>%
  mutate(., sie_z = as.numeric(scale(sie))) %>% 
  mutate(., rt_congruent_z = as.numeric(scale(rt_congruent))) %>% 
  mutate(., rt_incongruent_z = as.numeric(scale(rt_incongruent))) #%>% #view(., filter = "none")


STROOP_SPAN %>%
  filter(., id > 9999) %>%
  select(., c(id, ends_with("_z"))) %>% #view(.)
  select(., c(span_pos_z, span_pos_adj_z, sie_z, rt_congruent_z, rt_incongruent_z)) %>%
  cor(.) %>% 
  as_data_frame(rownames = "var1") %>% 
  tidyr::pivot_longer(cols = -var1, names_to = "var2", values_to = "coeff") %>%
  filter(., var1 != var2) %>%
  arrange(., desc(abs(coeff)))

  #GGally::ggpairs(.)
###########################################################################
## 
###########################################################################
sum_across_list <- list(
  mean = ~mean(na.omit(.x)),
  sd = ~sd(na.omit(.x)),
  n = ~length(na.omit(.x)))

span_scores

span_scores_agg <- span_scores %>% 
  summarise(., 
            across(-id, sum_across_list)
  ) 

span_scores_agg %>% view()

#Group by Id , trial number, convert vecotor to string and assign as a new variable?
```




"The WMC score was the total number of items recalled in the correct serial position."

Performance on each task was transformed into a z score based on a
database of thousands of scores from our laboratory. A *WMC composite* was created by averaging across the complex span tasks for each participant.

If a participant’s *WMC composite score* fell within the upper or lower quartiles compared to our database, the individual was invited to participate in a second session in which the AX-CPT was administered. For further task descriptions and information about construct validity and test–retest
reliability, see Barch et al. (2009), Unsworth et al. (2005), and Unsworth, Redick, Heitz, Broadway, and Engle (2009).

The study was a 2 (WMC) × 4 (trial type) × 2 (delay) design, with WMC (high, low) as a between-subjects factor, and trial type (AX, AY, BX, BY) and delay (short, long) as within-subjects factors. *Probe accuracy* was assessed by analysing error rates across trial types and additionally computing
signal-detection measures of sensitivity (d′-context) and bias (C) using AX hit rates and BX false alarms (Cohen et al., 1999). *Hit and false-alarm rates* equal to 0 or 1 were adjusted by .01. The mean of median correct RTs were also analysed. Alpha ¼ .05 was used for all statistical tests. Partial eta-squared (hp 2 ) is provided as an index of effect size.

```{r}

```

