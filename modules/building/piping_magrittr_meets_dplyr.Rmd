---
title: "`Piping: `magrittr` meets `dplyr`"
author: ""
#date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# **`magrittr` meets `dplyr`**


Although `dplyr` is one of the best libraries for data manipulation but its functionality is far superior when paired with the `magrittr` library. 

The piping operator `%>%` from the `magrittr` library takes an object (e.g., data frame object, model object, etc.) and "pipes" it into the first argument of the subsequent function; this first argument typically takes an object like a data frame. Rather than referencing the data frame for each function separately, the `%>%` allows for nesting functions, each which will inherit the returned object from the previous function. 


# **The Concept of Piping (using `magrittr`)**

We often need to get a subset of data using one function, and then use another function to do something with that subset (and we may do this multiple times). This leads to nesting functions, which can get messy and hard to keep track of. Enter 'piping', `dplyr`'s way of passing the object returned from one function to another function, and so on, without the hassle of parentheses and brackets.

Data frame manipulation take many forms. Perhaps you want to take a subset of columns (e.g., variables) or rows (e.g., cases) from a large data frame. Perhaps certain rows contain missing values for important variables or perhaps you want to select cases that match a particular rule (e.g., older than 35, between ages 15 and 22, individuals of certain ethnicities, etc.). 

In order to accomplish various data frame manipulation procedures, you would start with the data frame, do something to it, then do something else to it, etc. 

Because functions can return a modified data frame object, you could nest the functions so that the final returned data frame contains the last iteration of your desired changes. In other words, you would apply a function on the data frame, then apply another function on that returned data frame, and then apply another function on that returned data frame. 

Piping works on objects. Remember, objects can be vectors, data frames, lists, etc. Although you will typically use `%>%` to manipulate data frames, the first example demonstrates the usage with a simple vector object.


## **Examples Without Piping**

Below are two examples of code that can become messy, cumbersome, and less flexible than using `%>%` as you will see.

*First*, we will create an vector object (viz., `object1`) and then create new objects for each function needed to obtain the arithmetic mean of that vector. 

```{r}
object1 <- c(11.34, 44.13, 23.10, "87.60", "99.19")   # a vector containing strings and numerics

#is.vector(object1)                    # if you don't believe this is a vector, test it

object2 <- as.numeric(object1)         # convert to numeric

object3 <- mean(object2)               # calculate the mean of them

object4 <- round(object3, 1)           # round it

print(object4)
```


*Second*, we will take `object1`) and apply the same code by wrapping the functions. In this example, 
`function1()` is wrapped by `function2()` which is wrapped by `function3()`. Specifically, `as.numeric()` is wrapped by `mean()` which is wrapped by `round`()`.

Ex: `function3(function2(function1(object)))` 

```{r}
round(mean(as.numeric(object1)), 1)
```

As you can see with the nested functions, in order to understand the code, you have to read it from the inside outward (e.g., from right to left). Doing so is opposite of how you might normally read (e.g., from left to right).

Nested functions can be messy, can be difficult to follow, and are impossible to modify using code commenting (e.g., `#`) to prevent one of those functions because all functions run on the data frame. Although nesting functions can appear clean, the approach is inflexible to modifications or executing only certain functions in the line of code.


## **Example With Piping**

The `magrittr` package helps clean up these types of messes and provides a  more readable and modifiable alternative. We will start with an object and then modify that object with each line of code. In this way, the code is read from top to bottom, making it much more legible and the functions are not wrapped in other functions. By using the `%>%` pipe operator from `magrittr`, a more elegant and readable form of the above example looks like this:

`object %>%         # take this object`
  `function1(.) %>%  # do this to modify the object `
  `function2(.) %>%  # then do this to the modified object`
  `function3(.)      # and then do this to the modified modified object`


Tip: If you can remember, `ctrl + shift + m` (for pc) `cmd + shift + m (for mac)` is a hotkey combination for typing `%>%`.


Because each function needs an object to manipulate and the object name is typically visible in the function call (e.g., `object1` in  `as.numeric(object1))`, the `.` is used as a stand in for that object for illustration purposes. When you want to pass the object into a subsequent function when piping with `%>%`, you can use `.`. Doing so, However, is not typically needed because `magrittr` makes this an assumption of the process and you can typically omit `.` unless you need to add arguments to the function.  

Including `.` for all steps:

```{r}
object1 %>%           # take the object
  as.numeric(.) %>%   # use "." to reference the object and convert the object to numeric
  mean(.) %>%         # use "." to reference the object and calculate mean of the object
  round(., 1)         # use "." to reference the object and round it to 1 decimal
```

Excluding `.` except when passing function arguments:

```{r}
object1 %>%           # take the object
  as.numeric() %>%    # convert to numeric
  mean() %>%          # calculate mean
  round(., 1)         # use "." to reference the object
```


## **Commenting Out/Removing Function Calls**

## `#` **meets** `%>%`

When using `%>%`, functions are applied in isolation to the object inherited from the previous function call. Each line of code can be included or removed so that each is very readable. Greater flexibility comes with using `#` to "comment out" or remove lines of code. In the example below, by commenting out the line of code for calculating the `mean()` in the second function, the mean is never computed. Instead the object returned from `as.numeric()`is passed to the third function, `round()`. The final returned object is a vector of values rounded to 1 decimal.

Although this example is arbitrary, this flexibility is not possible with nested functions.

```{r}
object1 %>%           # take the object
  as.numeric() %>%    # convert to numeric
  #mean() %>%         # DO NOT calculate mean
  round(., 1)         # use "." to reference the data frame object; each element of vector is rounded
```









# **Data fame objects, `magrittr` and `dplyr`. ** 

The above example illustrated that `%>%` could be used to pass a vector object to other functions. In many instances, you will be working with data frames in order to clean, modify, plot, or model.

Below is the same logic when the object is a data frame:

```{r}
dataframe %>%     # take this data frame
  function1(.) %>% # do this to modified the data frame
  function2(.) %>% # then do this to the modified data frame
  function3(.)     # and then do this to the modified data frame
```

In this case, a data frame object is passed to different functions and the final returned data frame contains all of the applied functions in the piped code block. All lines of code except for the last line can be commented out if not desired to apply. If you wish to remove the last function, the final `%>%` needs to be removed because some operation needs to be applied after the usage of every `%>%`. For example, omit the second function.

Because `dplyr` is great for data frame manipulation, pairing it with `%>%`is useful for manipulating data frames in a clear and elegant way.


dataframe %>%      # take this data frame
  function1() %>%  # do this to modified the data frame
  #function2() %>% # then DO NOT do this to the modified data frame
  function3()      # but do this to the modified data frame

The returned data frame can also be assigned to overwrite itself

dataframe <- dataframe %>%  # # take this data frame and assign the returned data frame to the existing object (or a new object)
  function1() %>% # do this to modified the data frame
  function2() %>% # then do this to the modified data frame
  function3()     # and then do this to the modified data frame 

