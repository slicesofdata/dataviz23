---
title: "**Insert Module Name**"
author: "Gabriel I. Cook"
#date: "`r Sys.Date()`"
date: "`r format(Sys.time(), '%d %B, %Y')`"

# this is a test to fingure out why there is the following error when rendering many quarto files:
# ERROR: The filename, directory name, or volume label syntax is incorrect. (os error 123)
---

```{r}
#| label: load-packages
#| include: false

#library()
#library()
```

# **The Starter file**

## **Starter File**

# **Summarizing Data Using {dplyr}**

If you want a quick summary of data, `summary()` will provide some basic information for you.

```{r}
summary(DAT)
```

However, there are many other ways to summarize data. To introduce data summary techniques using **{dplyr}**, we will open the `diamonds` data set from the **{ggplot2}** library. Then, we will use `dplyr::summarise()` or `dplyr::summarize()` to summarize the data. The `summarise()` function works similar to `mutate()` insofar as variables are created but differs insofar as the data frame returned from `summarise()` contains only the variable(s) referenced in `summarize()`. 

In the example below, we summarize by creating a new variable which is set to represent some data summary technique. In essence, summarizing is for descriptive statistics. Using `mean()`, we can summarize the data by taking the mean of the `price` variable.

```{r}
diamonds <- ggplot2::diamonds   # assign data to object

diamonds %>%
  summarise(., 
            mean = mean(price, na.rm = T),
            )
```

Notice what is returned is a single value reflecting the mean of all the data in the data frame. We could have obtained the same without using **{dplyr}**.

```{r}
mean(diamonds$price, na.rm = T)        # $ notation
```

But we lose flexibility of easily adding new summary procedures. 

```{r}
diamonds %>%
  summarise(., 
            mean = mean(price, na.rm = T),
            sd   = sd(price, na.rm = T)
            )
```

Now there is a mean and standard deviation for price. You can also add the sample size using `dplyr::n()`. 

```{r}
diamonds %>%
  summarise(., 
            mean = mean(price, na.rm = T),
            sd   = sd(price, na.rm = T),
            n    = n()
            )
```


# **Summarizing `across()` Multiple Variables**

Summarizing a single variable is useful but if you want to summarize by many, you likely don't want to code a new line for each variable. In such cases, you can use `across()` as a helper function as was used for creating new variables with `mutate()` (see previous lesson).  

Remember `across()` will want you to pass the columns to summarize by, `.cols`, the function for how to summarize, `.fns`, and the names for how to name the new variables, `.names` (which will be `NULL` by default). The `.x` here stands for passing the vector to the mean function and not the data frame. More on `~` and `.x` later.

## *Summarize across by numeric variables...*

```{r}
diamonds %>%
  summarise(., across(.cols = where(is.numeric), 
                      .fns  = ~mean(.x, na.rm = TRUE))
            )
```

Passing `.names`...

```{r}
diamonds %>%
  summarise(., across(.cols = c("carat", "depth", "table"), 
                      .fns  = ~mean(.x, na.rm = TRUE),
                      .names = "{.col}_mean")
            )
```

## *Summarize across by variable name vector...*

```{r}
diamonds %>%
  summarise(., across(.cols = c("carat", "depth", "table"), 
                      .fns  = ~mean(.x, na.rm = TRUE),
                      .names = "{.col}_mean")
            )
```


# **Summarizing Data Using `group_by()`**

A summary of the entire data set is fine for understanding grand mean and other metrics but this lacks information at a group level, for example, by sex, ethnicity, personality, city, job title, or in the `diamonds` data by diamond `cut`, `clarity`, or other variation.

When summarizing data, you will often want to summarize by levels of other variables, either categorical or numeric. In such cases, you can `group_by()` another variable and then summarize.

Let's summarize in several ways after grouping by diamond `cut`.

```{r}
diamonds %>%
  group_by(., cut) %>%
  summarise(., 
            n = n(),  # or also length()
            mean = mean(price, na.rm = T),
            sd   = sd(price, na.rm = T)
            )
```

You see that price increases with `cut` quality. Using `str()` or `glimpse()` you can see `cut` is an ordered factor.

```{r}
diamonds %>% str()
```

But wow, that was a lot of coding lines. You might want to write your code to be more flexible so every variable is not hard coded. Could you imagine having 50 variables?

## *Passing multiple functions in a `list()`*

Doing this requires a little fancy coding by passing two functions as a `list` object.  A `list` is a special object (e.g., container) for which its elements can be different types of objects. Whereas elements of `vectors` can be only character or only numeric, elements of lists can hold different object. One element can be a numeric vector, another element a data frame, another element a character vector, etc. Many functions used in R will actually return lists for which elements contain different types of objects.

Back to two or more functions. If you pass a `list()` with arguments for the `mean` and the `sd` (e.g., `list(mean, sd)`, you can summarize by both. If you want to prevent errors (yes you do) and want to keep the summaries separate (probably so), you can modify `.names` to pass both the column and the function (e.g., `"{.col}_{.fn}"`). The underscore is not needed here; it only helps with readability of the variables so that you don't end up with variable names like `var1mean` but instead `var1_mean`.

Let's pass the summary procedures as a `list` to include measures of mean, standard deviation, and the sample size (number of observations) contributing to the mean and standard deviation. Unfortunately, `dplyr::n()` will throw an error when placed in the list. As you know,`length()` will also return the length of the vector but in this case as part of the the grouping variable because `group_by()` precedes the summary.

Here are a couple ways to do this, some of which may be better under certain scenarios. You have to determine what approach is best but I'll lay out some limitations. If you pass only the functions into the list, then when you pass `{.fn}` to `.names`, the variable names in the returned data frame will take on a numeric value representing the order/element position of the functions as you entered them in the `list`. In this coding instance, means would be named with`"_1"` and standard deviation names with `"_2"`. This approach, however, leads to confusing variable names because you have to remember which is 1 and which is 2 and of course explain this to anyone with whom you share the data. Let's take a look. 

```{r}
diamonds %>%
  group_by(., cut) %>%
  summarise(., across(.cols  = c("carat", "depth", "table"), 
                      .fns   = list(mean, sd, length),
                      .names = "{.col}_{.fn}")
            )
```

A better approach could be to assign the `mean` and `sd` functions names in the `list()` function call so that the name is appended and the variable is named meaningfully. Let's modify what we pass to `.fns`.

```{r}
diamonds %>%
  group_by(., cut) %>%
  summarise(., across(.cols = c("carat", "depth", "table"), 
                      .fns  = list(mean = mean, 
                                   sd = sd,
                                   n = length
                                   ),
                      .names = "{.col}_{.fn}")
            )
```

Importantly, however, if a vector contains even one `NA`, remember the returned statistic for the entire vector will also be `NA`. The previous code will *NOT* return correct statistics if you have an `NA`.

You will want to remove them either by filtering rows for `complete.cases()` or omitting `NA`s from the summary statistic function. To illustrate, let's make some data missing in the data frame. Because there are 53,940 rows in the data frame, we can simply make some data in the last row missing. Let's change the data in `depth` and `table` variables to `NA` just to illustrate the point.

```{r}
diamonds[53940, c("depth", "table")]   # the current data

diamonds[53940, c("depth", "table")] <- NA # set these cells to NA

tail(diamonds)               # see missing values
```

Now filter out missing cases...

```{r}
diamonds %>%
  filter(., complete.cases(.)) %>%
  group_by(., cut) %>%
  summarise(., across(.cols = c("carat", "depth", "table"), 
                      .fns  = list(mean = mean, 
                                   sd = sd,
                                   n = length),
                      .names = "{.col}_{.fn}"
            ))
```

That's likely the easiest approach but if there is an `NA` in some variables and not others (e.g., only `depth` and `table` here), the variables with complete cases will also lose data. Note how `n` is the same for all variables. 

What you may really want to do would be to compute the statistics by omitting `NA`s at the variable level. Now, `across()` has a way to handle this which involves passing an additional argument `na.rm = TRUE` which will adjust the functions, in this case mean and sd functions to include `na.rm = TRUE`. We can add this after `.names`. Unfortunately, however, `length()` annoyingly has no argument for removing `NA`s. If we drop it out of the list, we get the means and standard deviations. 
 
```{r}
diamonds %>%
  filter(., complete.cases(.)) %>%
  group_by(., cut) %>%
  summarise(., across(.cols = c("carat", "depth", "table"), 
                      .fns  = list(mean = mean, 
                                   sd = sd
                                   ),
                      .names = "{.col}_{.fn}",
                      na.rm = TRUE
            ))
```


So this doesn't solve the problem for all metrics you want to compute. What now?

Approach #1:

We can write our own function that contains `NA` removal in the same way. We just need to ensure we use `na.rm` and not something like `remove.na`. Let's name the function `length_na`.

```{r}
length_na <- function(x, na.rm = FALSE) {
# as length() substitute that calculates length with and without NAs
  if (na.rm) {
    x = length(na.omit(x))
  } else {
    x = length(x)
  }
  return(x)
}
```

And add `length_na` to the list...

```{r}
diamonds %>%
  filter(., complete.cases(.)) %>%
  group_by(., cut) %>%
  summarise(., across(.cols = c("carat", "depth", "table"), 
                      .fns  = list(mean = mean, 
                                   sd = sd,
                                   n = length_na
                                   ),
                      .names = "{.col}_{.fn}",
                      na.rm = TRUE
            ))
```

But this removed `NA` row-wise and not for each column variable independently. The `carat` variable should not have the name number of cases as `depth` and `table`, both of which contain missing cases. This approach just did the same thing as filtering by complete cases as done earlier with `filter(., complete.cases(.))`.


Approach #2:

When functions do not contain argument for dealing with `NA`s, there is `na.omit()`, a function that takes an object and removes `NA`s. So you can just pass the variable to `na.omit()` and then wrap it in the metric function of interest. Also, because `na.rm = T` cannot be used for `length()`, `na.omit()` offers consistency across all functions and as a result, I believe, less confusion.

Unfortunately, accomplishing this task can be rather tricky and requires some new syntax. This requires usage of what's called a "lambda" technique. Using this type of syntax, we can pass functions to the `.fns` argument. The `?across()` documentation calls it "a purrr-style lambda" in the arguments section (for clarity, `purrr` is a library). This approach can be a little bit confusing, so I’m going to show you an example, and then walk through it step by step.

We need to precede the function with `~` and reference the vector using `.x`. Let's do this and change the `.fns` argument slightly.

General Example:

`name = ~function(na.omit(.x))`

```{r}
diamonds %>%
  group_by(., cut) %>%
  summarise(., across(.cols = c("carat", "depth", "table"), 
                      .fns  = list(mean = ~mean(na.omit(.x)),
                                   sd = ~sd(na.omit(.x)),
                                   n = ~length(na.omit(.x))),
                      .names = "{.col}_{.fn}"
                      )
            )
```

Great! Now `carat` contains one more case than the other variables. So what's the point of all of this? Well, you need to be careful not to apply functions and assume they are doing what you believe you are doing. You always need to be smarter than the code you use. Also, there is no single answer for dealing with data. Sometimes one approach will be appropriate and in other instances another approach will be. You as the data scientist need to know that there are different methods so that you an decide where to apply those different methods. 


## *Grouping by multiple variables`*

OK, now this gets exciting. When you want to group by additional variables, pass a new one to `group_by()`. Just to keep the output more simple, let's remove one summary function.

```{r}
diamonds %>%
  group_by(., cut, clarity) %>%
  summarise(., across(.cols = c("carat", "depth", "table"), 
                      .fns  = list(mean = ~mean(na.omit(.x)),
#                                   sd = ~sd(na.omit(.x)),
                                   n = ~length(na.omit(.x))),
                      .names = "{.col}_{.fn}"
                      )
            )
```

# **The Data Manipulation Workflow: Putting It All Together**

Of course, all of this can be paired with `select()`, `mutate()`, `filter()`, etc. Here is the data manipulation workflow 

`dataframe %>%`
    `select(., ...) %>%     # select variables of interest`
    `mutate(., ...) %>%     # then create new variables`
    `filter(., ...) %>%     # then filter by rows`
    `group_by(., ...) %>%   # then group for subsetting`
    `summarize(., ...)      # then summarize`
