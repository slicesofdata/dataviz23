---
title: "Mental Rotation"
output: html_document
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
rm(list = ls(all.names = TRUE))      # remove objects in R

source("https://pastebin.com/raw/8mXH02yg")   # run and comment out before knitting
source("https://pastebin.com/raw/97NNTTzu")   # run to include in function definitions

# set the paths for project, script, and data dirs
proj_dir <- gsub("GCDS.*.Rmd", "GCDS", get_ActivePath())
proj_name = ""
r_dir    <- paste(proj_dir, "r", sep = "/")    # r subdir
data_dir <- paste(proj_dir, "data", sep = "/") # data subdir
if ( proj_name != "" & !dir.exists(paste(proj_dir, proj_name, sep = "/")) ) {
  # create project dir
  suppressWarnings(dir.create(paste(proj_dir, proj_name, sep = "/")))
  r_dir <- gsub("/r", paste0("/", proj_name, "/r"), r_dir)
  data_dir <- gsub("/data", paste0("/", proj_name, "/data"), data_dir)
  # create sub directories
  suppressWarnings(dir.create(r_dir))
  suppressWarnings(dir.create(data_dir)) }
```


# **Libraries**

```{r}
library(dplyr)
library(magrittr)
library(ggplot2)
```


# **Data**

```{r}
rot_dir <- paste(proj_dir, "mental_rotation", sep = "/")
rot_data_dir <- paste(rot_dir, "data", sep = "/")
#list.files(rot_dat_dir)

MR <- pavlovia_Merge(rot_data_dir, pattern_select = ".csv")

view(MR)
```

Select key variables and rename:

```{r}
MR <- MR %>% dplyr::select(., starts_with("task"))
MR <- MR %>% dplyr::select(., -c(task_date, task_exp, task_trial))

cleanNames <- function(dataframe) {
  names = tools::toTitleCase(tolower(names(dataframe)))
  names = gsub("Task_|task_", "", names)
  return(names)
}

names(MR) <- cleanNames(MR)
```


Create new variables and clean up:

```{r}
MR
MR <- MR %>%
  mutate(., 
         id = subid,
         trialtype = ifelse(
           left_img == right_img, "Same", "Mirror"),
         acc = ifelse(
           trialtype == "Same" & tolower(resp) == "j" |
           trialtype == "Mirror" & tolower(resp) == "f", 1, 0),
         rt = rt * 1000
         ) %>%
  mutate(., rt_NA = rt) %>%
  mutate(., rt = ifelse(acc == 1,   rt, NA)) %>%
  mutate(., rt = ifelse(rt < 10000, rt, NA)) %>%
  group_by(., id) %>%
  mutate(., trialnum = row_number()) %>%
  dplyr::select(, c(id, trialnum, trialtype, 
                    rotation, rt, rt_NA, acc))

hist(MR$rt)
write.csv(MR, paste(data_dir, "mental_rotation.csv", sep = "/"),
          row.names = F)
write.csv(MR, paste(rot_data_dir, "mental_rotation.csv", sep = "/"),
          row.names = F)
```

# **Aggregate Data by Id**

```{r}
MR_agg %>% view(., filter = "none")

MR_agg <- MR %>% 
  group_by(id, trialtype, rotation) %>%
  summarise(., 
            rt_na_mn  = mean(rt_NA, na.rm = T),
            rt_na_med = median(rt_NA, na.rm = T),
            rt_mn  = mean(rt, na.rm = T),
            rt_sd  = sd(rt, na.rm = T),
            rt_med = median(rt, na.rm = T),
            acc    = mean(acc, na.rm = T),
            )

write.csv(MR_agg, 
          paste(data_dir, "mental_rotation_agg.csv", sep = "/"),
          row.names = F)
write.csv(MR_agg, 
          paste(rot_data_dir, "mental_rotation_agg.csv", sep = "/"),
          row.names = F)

MR_summary_40 <- MR %>% 
  filter(., as.numeric(id) > 9999) %>%
  group_by(trialtype, rotation) %>%
  summarise(., 
            rt_mn = mean(rt, na.rm = T),
            rt_sd = sd(rt, na.rm = T),
            rt_med = median(rt, na.rm = T),
            acc = mean(acc, na.rm = T),
            )

MR_summary_gcds <- MR %>% 
  filter(., as.numeric(id) < 9999) %>%
  group_by(trialtype, rotation) %>%
  summarise(., 
            rt_mn = mean(rt, na.rm = T),
            rt_sd = sd(rt, na.rm = T),
            rt_med = median(rt, na.rm = T),
            acc = mean(acc, na.rm = T),
            )
```

# **Plots**

```{r}
MR_agg %>%
  filter(., id < 9999) %>%
  filter(., trialtype == "Same") %>%
  ggplot(data = ., 
       aes(x = rotation, y = rt_na_med)) +  
  geom_point() +
  geom_smooth(method = "lm", se = F, 
              color = "lightblue", alpha = .2) +
  scale_x_continuous(breaks = seq(0, 180, 30)) +
  facet_wrap(~id) +
  ggtitle("Response Times by Degree Rotation") +
  see::theme_modern()


MR_agg %>%
  filter(., trialtype == "Same") %>%
  ggplot(data = ., 
       aes(x = rotation, y = acc)) +   
  geom_col() +
  #geom_smooth(method = "lm", se = F, 
  #            color = "lightblue", alpha = .2) +
  scale_x_continuous(breaks = seq(0, 180, 30)) +
  scale_y_continuous(breaks = seq(0, 1, .20)) +
  facet_wrap(~id) +
  ggtitle("Accuracy Rate by Degree Rotation") +
  see::theme_modern()
```


# **Across all Ids**

```{r}
rt_rot_40 <- lm(rt_med ~ rotation, data = MR_summary_40)
performance::model_performance(rt_rot_40)
parameters::parameters(rt_rot_40)

rt_rot_gcds <- lm(rt_med ~ rotation, data = MR_summary_gcds)
performance::model_performance(rt_rot_gcds)
parameters::parameters(rt_rot_gcds)


MR_summary_40 %>%
  #filter(., trialtype == "Same") %>%
  ggplot(data = ., 
       aes(x = rotation, y = rt_med, color = trialtype)) + 
  geom_point() +
  geom_smooth(aes(color = trialtype), method = "lm", se = F, 
              alpha = .2) +
  scale_x_continuous(breaks = seq(0, 180, 30)) +
  ylab("response time (ms)") +
  xlab("rotation (degrees)") +
  ggtitle("Response Times by Degree Rotation") +
  see::theme_modern()
  
MR_agg %>%
  group_by(., rotation, trialtype) %>%
  summarize(., 
            rt_mn = mean(rt),
            acc   = mean(acc)
            ) %>%
  filter(., trialtype == "Same") %>%
  ggplot(data = ., aes(x = rotation, y = acc)) +   
  geom_col() +
  scale_x_continuous(breaks = seq(0, 180, 30)) +
  scale_y_continuous(breaks = seq(0, 1, .20)) +
  ylab("response time (ms)") +
  xlab("rotation (degrees)") +
  ggtitle("Accuracy Rate by Degree Rotation") +
  see::theme_modern()
```

```{r}
head(MR)

MR_wide_rt <- MR %>%
  group_by(., id, trialtype, rotation) %>%
  summarize(., 
            rt  = mean(na.omit(rt)),
    #        acc = mean(na.omit(acc))
            ) %>%
  #select(., -acc) %>%
  tidyr::pivot_wider(., 
                     names_from  = c(trialtype, rotation), #acc),
                     #names_glue = "{.value}_{rotation}", #names_prefix = "rot_",
                     values_from = rt
) 

write.csv(MR_wide_rt, 
          paste(data_dir, "mental_rotation_wide.csv", sep = "/"),
          row.names = F)
write.csv(MR_wide_rt, 
          paste(rot_data_dir, "mental_rotation_wide.csv", 
                sep = "/"), 
          row.names = F)
```




# **Supervised Linear Model**

Predict response time by trialtype and rotation.

If the refenence level is "Same", order the factor using `ordered = T`.

```{r}
MR_agg <- MR_agg %>% 
  mutate(., trialtype = factor(trialtype, 
                               levels = c("Same", "Mirror"), 
                               ordered = T))
str(MR_agg)

lm_MR <- MR_agg %>%
  lm(rt_med ~ id + trialtype + rotation, data = .) %>% lm.beta::lm.beta(.)

summary(lm_MR)

performance::model_performance(lm_MR)
```


# **Random Forest Model**

Unsupervised learning

```{r}
MR_wide_rt

library(ranger)
library(vip)
MR_wide_rt

# number of features
MR_rf <- MR_agg %>% select(., c(trialtype, rotation, rt_med))
n_features <- length(setdiff(names(MR_rf), "rt_med"))

# train a default random forest model
rf_MR <- ranger::ranger(
  rt_med ~ ., 
  data = MR_rf,
  mtry = floor(n_features / 3),
  respect.unordered.factors = "order",
  seed = 123
)

# get OOB RMSE
(default_rmse <- sqrt(rf_MR$prediction.error))

```

# Re-run model with *impurity-based* and *permutation-based* variable importance.

```{r}
rf_impurity_MR <- ranger(
  formula = rt_med ~ ., 
  data = MR_rf, 
  #num.trees = 2000,
  mtry = floor(n_features / 3),
  #min.node.size = 1,
  #sample.fraction = .80,
  #replace = FALSE,
  importance = "impurity",
  respect.unordered.factors = "order",
  #verbose = FALSE,
  seed  = 123
)

rf_permutation_MR <- ranger(
  formula = rt_med ~ ., 
  data = MR_rf, 
  #num.trees = 2000,
  mtry = floor(n_features / 3),
  #min.node.size = 1,
  #sample.fraction = .80,
  #replace = FALSE,
  importance = "permutation",
  respect.unordered.factors = "order",
  #verbose = FALSE,
  seed  = 123
)

rf_impurity_MR
?vip::vip
p1 <- vip::vip(rf_impurity_MR, num_features = 3, geom = "point")
p2 <- vip::vip(rf_permutation_MR, num_features = 3, geom = "point")
p1

gridExtra::grid.arrange(p1, p2, nrow = 1) #+ see::theme_modern()
```



# Unsupervised Clustering

```{r}
# Modeling packages
library(cluster)     # for general clustering algorithms
library(factoextra)  # for visualizing cluster results

MR_wide_rt
fviz_nbclust(MR_wide_rt, kmeans, method = "wss")

#calculate gap statistic based on number of clusters
gap_stat <- clusGap(MR_wide_rt,
                    FUN = kmeans,
                    nstart = 25,
                    K.max = 10,
                    B = 50)

#plot number of clusters vs. gap statistic
fviz_gap_stat(gap_stat)



#remove rows with missing values
str(MR_wide_rt)
view(MR_wide_rt)
MR_wide_rt <- na.omit(MR_wide_rt)

scale_it <- function(x) as.vector(scale(x))


#scale each variable to have a mean of 0 and sd of 1
MR_wide_rt <- ''
MR_wide_rt$id <- as.character(MR_wide_rt$id)
MR_wide_rt$Mirror_0 <- as.numeric(MR_wide_rt$Mirror_0)
MR_wide_rt %>%
  mutate(across(Mirror_0, ~ as.numeric(scale(.x)))) %>% view()

  mutate(across(mpg, ~ (. - mean(.)) / sd(.) ))
  mutate(., across(where(is.numeric), ~c(scale(.)))) %>% view()

#  mutate(., across(starts_with("S"), list(z = scale, log = log))) %>% view()

MR_wide_rt %>%
  #mutate(., across(where(is.numeric), .fns = ~scale(.x)))
  #  mutate(., Mirror_0 = as.vector(scale(Mirror_0))) %>% view()
#  mutate(., across(where(is.numeric), ~scaleOas.numeric(scale(.)))) %>% view()
  mutate(., across(.cols = where(is.numeric), 
                   .fns = ~as.vector((scale(.x))),
                   .names = "z_{.col}")) %>% view()
#%>%
  mutate(., across(.cols = where(is.numeric), scale_it, .names = "z_{.col}")) %>% view()
#  mutate(., across(.cols = where(is.numeric), scale, .names = "{.col}"))

as.vector((scale(MR_wide_rt$Mirror_0)))

#view first six rows of dataset
head(df)


```

